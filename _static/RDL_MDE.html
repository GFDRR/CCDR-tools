<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDLS Metadata Editor</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .section-checkbox {
            margin-bottom: 0.5rem;
        }
        .tab-content {
            min-height: 400px;
        }
        .nav-tabs .nav-link {
            border-radius: 0.5rem 0.5rem 0 0;
        }
        .nav-tabs .nav-link.hazard-tab {
            background-color: #e6f3ff;
            border-color: #007fc3;
            color: #007fc3;
        }
        .nav-tabs .nav-link.hazard-tab.active {
            background-color: #007fc3;
            border-color: #007fc3;
            color: white;
        }
        .nav-tabs .nav-link.exposure-tab {
            background-color: #e6fffe;
            border-color: #00cbab;
            color: #00cbab;
        }
        .nav-tabs .nav-link.exposure-tab.active {
            background-color: #00cbab;
            border-color: #00cbab;
            color: white;
        }
        .nav-tabs .nav-link.vulnerability-tab {
            background-color: #fff9e6;
            border-color: #ffc757;
            color: #b8941f;
        }
        .nav-tabs .nav-link.vulnerability-tab.active {
            background-color: #ffc757;
            border-color: #ffc757;
            color: white;
        }
        .nav-tabs .nav-link.loss-tab {
            background-color: #ffe6ec;
            border-color: #f3436a;
            color: #f3436a;
        }
        .nav-tabs .nav-link.loss-tab.active {
            background-color: #f3436a;
            border-color: #f3436a;
            color: white;
        }
        .nav-tabs .nav-link.general-tab {
            background-color: #f8f9fa;
            border-color: #6c757d;
            color: #6c757d;
        }
        .nav-tabs .nav-link.general-tab.active {
            background-color: #6c757d;
            border-color: #6c757d;
            color: white;
        }
        .form-field { 
            margin-bottom: 1rem; 
            position: relative;
        }
        .validation-indicator {
            position: absolute;
            right: 10px;
            top: 35px;
            z-index: 10;
            font-size: 1.2rem;
        }
        .validation-indicator.valid {
            color: #28a745;
        }
        .validation-indicator.invalid {
            color: #dc3545;
        }
        .field-with-validation {
            padding-right: 35px;
        }
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .autocomplete-suggestion {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
        }
        .autocomplete-suggestion:hover {
            background-color: #f8f9fa;
        }
        .combobox-wrapper {
            position: relative;
        }
        .combobox-wrapper .dropdown-toggle {
            border-left: none;
            padding: 0.375rem 0.5rem;
        }
        .combobox-wrapper .form-control {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        .combobox-wrapper .btn {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
        .array-field { 
            border: 1px solid #dee2e6; 
            padding: 1rem; 
            border-radius: 0.375rem; 
            margin-bottom: 1rem; 
            background-color: #fafafa;
        }
        .array-item { 
            background-color: #f8f9fa; 
            padding: 0.5rem; 
            margin: 0.5rem 0; 
            border-radius: 0.25rem; 
            border: 1px solid #e9ecef;
        }
        .object-field { 
            border: 1px solid #e9ecef; 
            padding: 1rem; 
            border-radius: 0.375rem; 
            margin-bottom: 1rem; 
            background-color: #fbfcfd; 
        }
        .required { 
            border-left: 3px solid #dc3545; 
            padding-left: 0.5rem;
        }
        .schema-status {
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }
        .file-drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            margin: 1rem 0;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }
        .file-drop-zone:hover { border-color: #007bff; }
        .file-drop-zone.dragover { border-color: #28a745; background-color: #f8f9fa; }
        .validation-progress {
            margin-bottom: 1rem;
        }
        .object-summary-card {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }
        .object-summary-title {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }
        .object-summary-details {
            font-size: 0.875rem;
            color: #6c757d;
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
        }
        .object-modal {
            max-width: 800px;
        }
        .modal-form-field {
            margin-bottom: 1rem;
        }
        .field-hint {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 0.25rem;
        }
        .bbox-field {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .bbox-field input {
            font-size: 0.9rem;
        }
        .bbox-preview {
            background-color: #f8f9fa !important;
            font-family: 'Courier New', monospace !important;
            color: #495057;
            border: 1px solid #ced4da;
        }

        /* Inline array editing styles */
        .array-field .card {
            border-left: 4px solid #0d6efd;
            margin-bottom: 0.75rem;
        }

        .array-field .card .card-body {
            background-color: #f8f9ff;
        }

        .array-field .modal-form-field {
            margin-bottom: 0.75rem;
        }

        .array-field .card:hover {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }

        /* Special styling for problematic nested arrays */
        .array-field[data-array-name*="disaster_identifiers"] .card {
            border-left-color: #dc3545;
        }

        .array-field[data-array-name*="disaster_identifiers"] .card .card-body {
            background-color: #fff5f5;
        }

    </style>
</head>
<body>
    <div class="container-fluid">
        <header class="py-4 border-bottom">
            <div class="d-flex align-items-center gap-3">
                <img src="https://gfdrr.github.io/CCDR-tools/_static/logo_flat.png" alt="GFDRR Logo" style="height: 100px;">
                <div>
                    <h1 class="h3 mb-1">RDLS Metadata Editor</h1>
                    <p class="text-muted mb-0">
                        Unified field creation system with improved maintainability
                        <span class="badge bg-primary ms-2">Refactored</span>
                    </p>
                </div>
            </div>
        </header>

        <div class="row mt-4">
            <!-- Configuration Panel -->
            <div class="col-md-3">
                <!-- Schema Version Selection -->
                <div class="card mb-3">
                    <div class="card-header">
                        <h5>📋 Schema Configuration</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label">Schema Version:</label>
                            <select id="schemaVersionSelect" class="form-select">
                                <option value="">Loading schema versions...</option>
                            </select>
                            <div id="schemaStatus" class="schema-status text-muted"></div>
                        </div>

                        <!-- Section Selectors -->
                        <div class="mb-3">
                            <label class="form-label">Dataset Sections:</label>
                            <div class="section-checkbox">
                                <input type="checkbox" id="generalCheck" class="form-check-input" checked disabled>
                                <label for="generalCheck" class="form-check-label ms-2">
                                    <span class="badge bg-secondary">General Metadata</span> (Required)
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="hazardCheck" class="form-check-input">
                                <label for="hazardCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #007fc3;">Hazard Metadata</span>
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="exposureCheck" class="form-check-input">
                                <label for="exposureCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #00cbab;">Exposure Metadata</span>
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="vulnerabilityCheck" class="form-check-input">
                                <label for="vulnerabilityCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #ffc757">Vulnerability Metadata</span>
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="lossCheck" class="form-check-input">
                                <label for="lossCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #f3436a;">Loss Metadata</span>
                                </label>
                            </div>
                        </div>

                        <!-- Custom Schema Upload -->
                        <div class="mb-3">
                            <label class="form-label">Custom Schema:</label>
                            <div class="file-drop-zone" id="schemaDropZone">
                                <small>📁 Drop RDLS schema file here<br>or click to browse</small>
                                <input type="file" id="schemaFile" accept=".json" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Actions Panel -->
                <div class="card">
                    <div class="card-header">
                        <h6>💾 Data Management</h6>
                    </div>
                        <div class="card-body">
                            <button id="loadData" class="btn btn-outline-secondary btn-sm w-100 mb-2">Load Existing Metadata</button>
                            <button id="saveProgress" class="btn btn-outline-info btn-sm w-100 mb-2">Save Progress</button>
                            <button id="resetForm" class="btn btn-outline-warning btn-sm w-100 mb-2">🔄 Reset All Data</button>
                            <button id="exportJson" class="btn btn-success btn-sm w-100 mb-2">Export JSON</button>
                            <button id="exportXml" class="btn btn-success btn-sm w-100 mb-2">Export XML</button>
                            <button id="validateForm" class="btn btn-outline-primary btn-sm w-100 mt-2">🔍 Validate Metadata</button>
                        </div>
                </div>
            </div>

            <!-- Form Generation Area -->
            <div class="col-md-6">
                <div class="card h-100">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5>📋 RDLS Metadata Form</h5>
                        <span id="formStatus" class="badge bg-secondary">No schema loaded</span>
                    </div>
                    <div class="card-body">
                        <!-- Tab Navigation -->
                        <ul class="nav nav-tabs" id="metadataTabs" role="tablist" style="display: none;">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active general-tab" id="general-tab" data-bs-toggle="tab" data-bs-target="#general" type="button" role="tab">
                                    General
                                </button>
                            </li>
                        </ul>

                        <!-- Tab Content -->
                        <div class="tab-content" id="metadataTabContent">
                            <div class="tab-pane fade show active" id="general" role="tabpanel">
                                <div id="metadataForm">
                                    <div class="text-center text-muted py-5">
                                        <div style="font-size: 4rem;">🌍</div>
                                        <p>Schema will load automatically and configure sections as needed</p>
                                        <small class="text-muted">Refactored with unified field creation and improved dependency handling</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Output Preview -->
            <div class="col-md-3">
                <div class="card h-100">
                    <div class="card-header">
                        <h6>👀 Live Preview & Validation</h6>
                    </div>
                    <div class="card-body">
                        <!-- Validation Progress -->
                        <div class="validation-progress">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <small class="text-muted"><strong>Validation Status</strong></small>
                                <span id="overallValidation" class="badge bg-secondary">Not validated</span>
                            </div>
                            <div class="progress mb-2" style="height: 8px;">
                                <div id="validationProgress" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                            </div>
                            <small class="text-muted">
                                <span id="validFieldCount">0</span>/<span id="totalFieldCount">0</span> fields valid
                            </small>
                        </div>
                        
                        <pre id="outputPreview" class="bg-light p-3 rounded" style="font-size: 0.8rem; max-height: 600px; overflow-y: auto;">
{
  "message": "Refactored RDLS metadata will appear here..."
}
                        </pre>
                        
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Object Editor Modal -->
    <div class="modal fade" id="objectEditorModal" tabindex="-1" aria-labelledby="objectEditorModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg object-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="objectEditorModalLabel">Edit Object</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="objectEditorForm" class="needs-validation" novalidate>
                        <div id="objectEditorFields">
                            <!-- Dynamic form fields will be inserted here -->
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveObjectBtn">Save Object</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Include Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>

    <script>
        // RDLS Schema Configuration
        const RDLS_VERSIONS = {
            '0.2': 'https://docs.riskdatalibrary.org/en/0__2__0/rdls_schema.json',
            '0.3': 'rdls_schema_v3.json'
        };

        const SECTIONS = ['hazard', 'exposure', 'vulnerability', 'loss'];
        
        let currentSchema = null;
        let currentFormData = {};
        let activeSections = new Set(['general']);
        let fieldValidationStatus = new Map();

        // Object editor state
        let currentObjectEditor = {
            arrayName: null,
            objectIndex: null,
            objectSchema: null,
            arrayData: null,
            renderCallback: null
        };

        // Country names cache
        let countryNames = {};

        // Dependency configuration - centralized
        const FIELD_DEPENDENCIES = {
            'vulnerability.hazard_process_primary': 'vulnerability.hazard_primary',
            'vulnerability.hazard_process_secondary': 'vulnerability.hazard_secondary',
            'loss.hazard_process': 'loss.hazard_type',
            'loss.impact_and_losses.currency': 'loss.impact_and_losses.impact_unit',
            'loss.losses.impact_and_losses.currency': 'loss.losses.impact_and_losses.impact_unit',
            'hazards.processes': 'hazards.type',
            'hazards.intensity_measure': 'hazards.type',
            // Modal context dependencies
            'processes': 'type',
            'hazard_process': 'hazard_type',
            'currency': 'impact_unit',
            // Fix for quantity_kind → currency dependency
            'currency': 'quantity_kind'
        };

        // Auto-completion suggestions for common fields
        const AUTO_COMPLETE_SUGGESTIONS = {
            'title': [
                'Global Flood Risk Assessment',
                'Earthquake Hazard Database',
                'Climate Change Vulnerability Index',
                'Urban Exposure Inventory',
                'Disaster Loss Database'
            ],
            'publisher.name': [
                'World Bank Group',
                'United Nations Office for Disaster Risk Reduction',
                'European Space Agency',
                'National Weather Service'
            ],
            'creator.name': [
                'International Research Institute',
                'National Disaster Management Agency',
                'Climate Change Research Center'
            ],
            'purpose': [
                'Risk assessment for urban planning',
                'Insurance portfolio analysis',
                'Climate adaptation planning',
                'Disaster risk reduction strategy development'
            ]
        };

        // ================================
        // UNIFIED FIELD CREATION SYSTEM
        // ================================
        
        /**
         * Unified Field Creation Context
         * Handles all field creation needs across normal, modal, and array contexts
         */
        class FieldCreationContext {
            constructor(type = 'normal', container = null) {
                this.type = type; // 'normal', 'modal', 'inline', 'array'
                this.container = container;
                this.idPrefix = type === 'modal' ? 'modal_' : '';
            }

            createField(name, property, value, options = {}) {
                const factory = new UnifiedFieldFactory(this);
                return factory.createField(name, property, value, options);
            }

            getFieldId(name) {
                return this.idPrefix + name;
            }

            setupEventListeners(element, name, property, options = {}) {
                const handler = new UnifiedEventHandler(this);
                handler.setupListeners(element, name, property, options);
            }

            validateField(name, value, property) {
                const validator = new UnifiedFieldValidator(this);
                return validator.validate(name, value, property);
            }
        }

        /**
         * Unified Field Factory
         * Creates appropriate field elements based on property type and context
         */
        class UnifiedFieldFactory {
            constructor(context) {
                this.context = context;
            }

            createField(name, property, value, options = {}) {
                // Skip ID fields in certain contexts
                if (name === 'id' || (name.includes('.id') && this.context.type === 'array')) {
                    return document.createElement('div');
                }

                // Skip trigger fields in hazard modal context - they're not needed for basic hazard entry
                if (this.context.type === 'modal' && name.includes('trigger')) {
                    return document.createElement('div');
                }

                const container = this.createFieldContainer(name, property, options);
                
                // Resolve $ref if present
                const resolvedProperty = this.resolveProperty(property);
                if (!resolvedProperty || !resolvedProperty.type) {
                    return container;
                }

                // Create label and description if not an object property
                const forceLabel = false;
                const isObjectProperty = resolvedProperty.type === 'object' && this.context.type !== 'modal' && this.context.type !== 'inline' && !name.includes('trigger') && !forceLabel;
                if (!isObjectProperty) {
                    this.addLabelAndDescription(container, name, resolvedProperty, options);
                }

                // Create the input element
                const inputElement = this.createInputElement(name, resolvedProperty, value, options);
                
                // Add validation indicator
                if (this.context.type === 'normal') {
                    this.addValidationIndicator(container, name);
                }

                container.appendChild(inputElement);

                // Add examples if available
                this.addExamples(container, resolvedProperty);

                // Handle dependencies
                this.handleDependencies(container, name, resolvedProperty, value);

                return container;
            }

            createFieldContainer(name, property, options) {
                const container = document.createElement('div');
                container.className = (this.context.type === 'modal' || this.context.type === 'inline') ? 'modal-form-field' : 'form-field';
                
                // Handle required fields
                if (this.isRequiredField(name, property, options)) {
                    container.classList.add('required');
                }

                return container;
            }

            resolveProperty(property) {
                if (property.$ref) {
                    const resolved = resolveReference(property.$ref);
                    if (resolved) {
                        return { ...resolved, title: property.title || resolved.title, description: property.description || resolved.description };
                    }
                }
                return property;
            }

            addLabelAndDescription(container, name, property, options) {
                const label = document.createElement('label');
                label.textContent = property.title || name.split('.').pop();
                label.className = 'form-label';
                label.htmlFor = this.context.getFieldId(name);
                
                if (this.isRequiredField(name, property, options)) {
                    label.innerHTML += ' <span class="text-danger">*</span>';
                }
                
                container.appendChild(label);
                
                if (property.description) {
                    const description = document.createElement('small');
                    description.className = 'form-text text-muted d-block mb-2';
                    description.innerHTML = parseMarkdownLinks(property.description);
                    container.appendChild(description);
                }
            }

            createInputElement(name, property, value, options) {
                switch (property.type) {
                    case 'string':
                        return this.createStringInput(name, property, value, options);
                    case 'integer':
                    case 'number':
                        return this.createNumberInput(name, property, value, options);
                    case 'boolean':
                        return this.createBooleanInput(name, property, value, options);
                    case 'array':
                        return this.createArrayInput(name, property, value, options);
                    case 'object':
                        return this.createObjectInput(name, property, value, options);
                    default:
                        return this.createStringInput(name, property, value, options);
                }
            }

            createStringInput(name, property, value, options) {
                // Check for dependencies
                const dependsOn = FIELD_DEPENDENCIES[name];
                if (dependsOn) {
                    const parentValue = getNestedValue(currentFormData, dependsOn);
                    return this.createDependentSelect(name, property, value, dependsOn, parentValue, options);
                }

                if (property.enum) {
                    return this.createSelect(name, property, value, options);
                } else if (property.suggestions && property.openCodelist) {
                    return this.createCombobox(name, property, value, options);
                } else if (property.format === 'date') {
                    return this.createDateInput(name, property, value, options);
                } else if (property.format === 'email') {
                    return this.createEmailInput(name, property, value, options);
                } else if (property.format === 'iri') {
                    return this.createUrlInput(name, property, value, options);
                } else if (name.includes('description') || name.includes('purpose') || name.includes('notes') || name.includes('details')) {
                    return this.createTextareaInput(name, property, value, options);
                } else {
                    return this.createTextInput(name, property, value, options);
                }
            }

            createTextInput(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                if (property.minLength) input.minLength = property.minLength;
                if (property.maxLength) input.maxLength = property.maxLength;
                if (property.pattern) input.pattern = property.pattern;
                
                this.context.setupEventListeners(input, name, property, options);
                wrapper.appendChild(input);
                
                // Setup autocomplete if not in modal or inline
                if (this.context.type !== 'modal' && this.context.type !== 'inline') {
                    this.setupAutoComplete(input, name, property);
                }
                
                return wrapper;
            }

            createTextareaInput(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';

                const textarea = document.createElement('textarea');
                textarea.className = 'form-control field-with-validation';
                textarea.name = this.context.getFieldId(name);
                textarea.id = this.context.getFieldId(name);
                textarea.value = value || '';
                textarea.rows = 3;
                textarea.style.resize = 'vertical';
                textarea.style.minHeight = '80px';

                if (property.minLength) textarea.minLength = property.minLength;
                if (property.maxLength) textarea.maxLength = property.maxLength;

                // Auto-resize functionality
                const autoResize = () => {
                    textarea.style.height = 'auto';
                    textarea.style.height = Math.max(80, textarea.scrollHeight) + 'px';
                };

                textarea.addEventListener('input', autoResize);
                textarea.addEventListener('focus', autoResize);

                // Initial resize
                setTimeout(autoResize, 0);

                this.context.setupEventListeners(textarea, name, property, options);
                wrapper.appendChild(textarea);

                return wrapper;
            }

            createEmailInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = 'email';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createUrlInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = 'url';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createDateInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = 'date';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createNumberInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = property.type === 'integer' ? 'number' : 'number';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                if (property.minimum !== undefined) input.min = property.minimum;
                if (property.maximum !== undefined) input.max = property.maximum;
                if (property.type === 'integer') input.step = '1';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createBooleanInput(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.className = 'form-check';
                
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-check-input';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.checked = value || false;
                
                const label = document.createElement('label');
                label.className = 'form-check-label';
                label.htmlFor = this.context.getFieldId(name);
                label.textContent = property.title || name;
                
                this.context.setupEventListeners(input, name, property, options);
                
                wrapper.appendChild(input);
                wrapper.appendChild(label);
                return wrapper;
            }

            createSelect(name, property, value, options) {
                const select = document.createElement('select');
                select.className = 'form-select field-with-validation';
                select.name = this.context.getFieldId(name);
                select.id = this.context.getFieldId(name);
                
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select an option...';
                select.appendChild(emptyOption);
                
                // Handle country dropdowns
                if (name.includes('countries') || (property.items && property.items.enum && property.items.enum.includes('USA'))) {
                    property.enum.forEach((option) => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        const countryName = countryNames[option] || option;
                        optionElement.textContent = `${option} - ${countryName}`;
                        if (value === option) optionElement.selected = true;
                        select.appendChild(optionElement);
                    });
                } else {
                    property.enum.forEach((option, index) => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        optionElement.textContent = property.enumNames ? property.enumNames[index] : 
                            option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        if (value === option) optionElement.selected = true;
                        select.appendChild(optionElement);
                    });
                }
                
                this.context.setupEventListeners(select, name, property, options);
                return select;
            }

            createDependentSelect(name, property, value, dependsOn, parentValue, options) {
                const select = document.createElement('select');
                select.className = 'form-select field-with-validation';
                select.name = this.context.getFieldId(name);
                select.id = this.context.getFieldId(name);
                select.setAttribute('data-depends-on', dependsOn);
                
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select an option...';
                select.appendChild(emptyOption);
                
                // Start with all available options
                let availableOptions = property.enum || [];
                
                // Filter options if we have a parent value
                if (parentValue && currentSchema.hazard_process_mappings && name.includes('process')) {
                    availableOptions = currentSchema.hazard_process_mappings[parentValue] || property.enum || [];
                }
                
                // Populate options
                availableOptions.forEach((option, index) => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = property.enumNames ? property.enumNames[index] : 
                        option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    if (value === option) optionElement.selected = true;
                    select.appendChild(optionElement);
                });
                
                this.context.setupEventListeners(select, name, property, options);
                return select;
            }

            createCombobox(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';
                wrapper.className = 'combobox-wrapper';
                
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                input.placeholder = 'Type or select from suggestions...';
                
                if (property.minLength) input.minLength = property.minLength;
                if (property.maxLength) input.maxLength = property.maxLength;
                if (property.pattern) input.pattern = property.pattern;
                
                const dropdownBtn = document.createElement('button');
                dropdownBtn.type = 'button';
                dropdownBtn.className = 'btn btn-outline-secondary dropdown-toggle';
                dropdownBtn.setAttribute('data-bs-toggle', 'dropdown');
                
                const dropdownMenu = document.createElement('ul');
                dropdownMenu.className = 'dropdown-menu';
                dropdownMenu.style.maxHeight = '200px';
                dropdownMenu.style.overflowY = 'auto';
                
                if (property.suggestions && property.suggestions.length > 0) {
                    property.suggestions.forEach(suggestion => {
                        const item = document.createElement('li');
                        const link = document.createElement('a');
                        link.className = 'dropdown-item';
                        link.href = '#';
                        link.textContent = suggestion;
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            input.value = suggestion;
                            updateFormData();
                            this.context.validateField(name, suggestion, property);
                        });
                        item.appendChild(link);
                        dropdownMenu.appendChild(item);
                    });
                    
                    const separator = document.createElement('li');
                    separator.innerHTML = '<hr class="dropdown-divider">';
                    dropdownMenu.appendChild(separator);
                    
                    const customItem = document.createElement('li');
                    customItem.innerHTML = '<span class="dropdown-item-text text-muted"><em>💡 You can also type a custom value</em></span>';
                    dropdownMenu.appendChild(customItem);
                }
                
                inputGroup.appendChild(input);
                inputGroup.appendChild(dropdownBtn);
                inputGroup.appendChild(dropdownMenu);
                
                this.context.setupEventListeners(input, name, property, options);
                wrapper.appendChild(inputGroup);
                
                if (this.context.type !== 'modal' && this.context.type !== 'inline') {
                    this.setupAutoComplete(input, name, property);
                }
                
                return wrapper;
            }

            createArrayInput(name, property, value, options) {
                if (name.includes('bbox')) {
                    return this.createBboxInput(name, property, value, options);
                } else {
                    return this.createGenericArrayInput(name, property, value, options);
                }
            }

            createBboxInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'bbox-field border p-3 rounded bg-light';
                
                const title = document.createElement('h6');
                title.textContent = 'Bounding Box Coordinates (SW Longitude, SW Latitude, NE Longitude, NE Latitude)';
                title.className = 'mb-3';
                container.appendChild(title);
                
                const bboxData = value || [0, 0, 0, 0];
                const labels = ['SW Longitude', 'SW Latitude', 'NE Longitude', 'NE Latitude'];
                
                const inputsContainer = document.createElement('div');
                inputsContainer.className = 'row g-2';
                
                function updateBboxPreview() {
                    const currentBbox = getNestedValue(currentFormData, name) || [0, 0, 0, 0];
                    const previewInput = container.querySelector('.bbox-preview');
                    if (previewInput) {
                        previewInput.value = `[${currentBbox.join(', ')}]`;
                    }
                }
                
                for (let i = 0; i < 4; i++) {
                    const col = document.createElement('div');
                    col.className = 'col-md-6';
                    
                    const label = document.createElement('label');
                    label.textContent = labels[i];
                    label.className = 'form-label';
                    
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = 'any';
                    input.className = 'form-control';
                    input.name = `${this.context.getFieldId(name)}_${i}`;
                    input.value = bboxData[i] || 0;
                    input.placeholder = i % 2 === 0 ? 'Longitude' : 'Latitude';
                    
                    input.addEventListener('input', function() {
                        const currentBbox = getNestedValue(currentFormData, name) || [0, 0, 0, 0];
                        currentBbox[i] = parseFloat(this.value) || 0;
                        setNestedValue(currentFormData, name, currentBbox);
                        updateFormData();
                        updateBboxPreview();
                    });
                    
                    col.appendChild(label);
                    col.appendChild(input);
                    inputsContainer.appendChild(col);
                }
                
                container.appendChild(inputsContainer);
                
                const previewContainer = document.createElement('div');
                previewContainer.className = 'mt-3';
                
                const previewLabel = document.createElement('label');
                previewLabel.textContent = 'Bounding Box Array Format:';
                previewLabel.className = 'form-label';
                
                const previewInput = document.createElement('input');
                previewInput.type = 'text';
                previewInput.className = 'form-control bbox-preview';
                previewInput.readOnly = true;
                previewInput.value = `[${bboxData.join(', ')}]`;
                previewInput.style.backgroundColor = '#f8f9fa';
                previewInput.style.fontFamily = 'monospace';
                
                previewContainer.appendChild(previewLabel);
                previewContainer.appendChild(previewInput);
                container.appendChild(previewContainer);
                
                return container;
            }

            createGenericArrayInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'array-field';
                container.setAttribute('data-array-name', name);
                
                // Ensure arrayData is always an array and maintains reference to original data
                let arrayData;
                if (Array.isArray(value)) {
                    arrayData = value;
                } else {
                    arrayData = [];
                    // For modal context, update the original object data immediately
                    if (this.context.type === 'modal') {
                        // Set the empty array in the source data so it gets properly saved
                        if (name && typeof name === 'string') {
                            // This will be handled by the modal save function
                        }
                    }
                }
                
                const itemsContainer = document.createElement('div');
                itemsContainer.id = `${this.context.getFieldId(name)}_items`;
                
                const renderArrayItems = () => {
                    itemsContainer.innerHTML = '';
                    
                    if (property.items && (property.items.$ref || property.items.type === 'object')) {
                        // Check if this is a problematic nested array that should be inline
                        const isProblematicArray = name.endsWith('.disaster_identifiers') ||
                                                 name === 'disaster_identifiers';

                        // For problematic arrays or modal context, create inline editing instead of opening new modals
                        if (this.context.type === 'modal' || isProblematicArray) {
                            arrayData.forEach((item, index) => {
                                const itemCard = this.createInlineObjectEditor(item, index, name, property, arrayData, renderArrayItems);
                                itemsContainer.appendChild(itemCard);
                            });
                        } else {
                            arrayData.forEach((item, index) => {
                                const objectCard = createObjectSummaryCard(item, index, name, property);
                                itemsContainer.appendChild(objectCard);
                            });
                        }
                    } else {
                        arrayData.forEach((item, index) => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'array-item d-flex gap-2 align-items-center mb-2';
                            
                            let input;
                            let itemSchema = property.items;
                            if (!itemSchema && property.$ref) {
                                itemSchema = resolveReference(property.$ref);
                            }
                            
                            if (itemSchema && itemSchema.type === 'string') {
                                if (itemSchema.enum) {
                                    input = document.createElement('select');
                                    input.className = 'form-select';
                                    
                                    const emptyOption = document.createElement('option');
                                    emptyOption.value = '';
                                    emptyOption.textContent = 'Select...';
                                    input.appendChild(emptyOption);
                                    
                                    if (itemSchema.enum.includes('USA') || itemSchema.enum.includes('GBR')) {
                                        itemSchema.enum.forEach((option) => {
                                            const optionElement = document.createElement('option');
                                            optionElement.value = option;
                                            const countryName = countryNames[option] || option;
                                            optionElement.textContent = `${option} - ${countryName}`;
                                            if (item === option) optionElement.selected = true;
                                            input.appendChild(optionElement);
                                        });
                                    } else {
                                        itemSchema.enum.forEach((option, idx) => {
                                            const optionElement = document.createElement('option');
                                            optionElement.value = option;
                                            optionElement.textContent = itemSchema.enumNames ? 
                                                itemSchema.enumNames[idx] : option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                                            if (item === option) optionElement.selected = true;
                                            input.appendChild(optionElement);
                                        });
                                    }
                                } else {
                                    input = document.createElement('input');
                                    input.type = 'text';
                                    input.className = 'form-control';
                                    input.value = item;
                                }
                                
                                input.addEventListener('change', (e) => {
                                    if (Array.isArray(arrayData) && index < arrayData.length) {
                                        arrayData[index] = e.target.value;
                                        if (this.context.type === 'normal') {
                                            updateFormData();
                                        }
                                    }
                                });
                            } else {
                                input = document.createElement('input');
                                input.type = 'text';
                                input.className = 'form-control';
                                input.value = item || '';
                                
                                input.addEventListener('change', (e) => {
                                    arrayData[index] = e.target.value;
                                    if (this.context.type === 'normal') {
                                        updateFormData();
                                    }
                                });
                            }
                            
                            const removeBtn = document.createElement('button');
                            removeBtn.type = 'button';
                            removeBtn.className = 'btn btn-outline-danger btn-sm';
                            removeBtn.textContent = '×';
                            removeBtn.addEventListener('click', () => {
                                arrayData.splice(index, 1);
                                renderArrayItems();
                                if (this.context.type === 'normal') {
                                    updateFormData();
                                }
                            });
                            
                            itemDiv.appendChild(input);
                            itemDiv.appendChild(removeBtn);
                            itemsContainer.appendChild(itemDiv);
                        });
                    }
                };
                
                const addBtn = document.createElement('button');
                addBtn.type = 'button';
                addBtn.className = 'btn btn-outline-primary btn-sm mb-2';
                addBtn.textContent = `+ Add ${property.title || name}`;
                addBtn.addEventListener('click', () => {
                    if (property.items.$ref || property.items.type === 'object') {
                        // Check if this is a problematic array that should be inline
                        const isProblematicArray = name.endsWith('.disaster_identifiers') ||
                                                 name === 'disaster_identifiers';

                        // For modal context or problematic arrays, add inline object instead of opening new modal
                        if (this.context.type === 'modal' || isProblematicArray) {
                            const newItem = {};
                            
                            // Initialize with appropriate ID based on object type
                            if (name === 'metrics') {
                                newItem.id = generateUniqueId('metric');
                            } else if (name === 'cost') {
                                newItem.id = generateUniqueId('cost');
                            } else if (name === 'hazards') {
                                newItem.id = generateUniqueId('hazard');
                            } else {
                                newItem.id = generateUniqueId('item');
                            }
                            
                            arrayData.push(newItem);
                            renderArrayItems();
                        } else {
                            openObjectEditor(name, arrayData.length, property.items, arrayData, renderArrayItems);
                        }
                    } else if (property.items.type === 'string') {
                        arrayData.push('');
                        renderArrayItems();
                        if (this.context.type === 'normal') {
                            updateFormData();
                        }
                    } else {
                        arrayData.push({});
                        renderArrayItems();
                        if (this.context.type === 'normal') {
                            updateFormData();
                        }
                    }
                });
                
                container.appendChild(addBtn);
                container.appendChild(itemsContainer);
                
                renderArrayItems();
                return container;
            }

            createInlineObjectEditor(item, index, arrayName, arrayProperty, arrayData, renderCallback) {
                const card = document.createElement('div');
                card.className = 'card mb-2';
                card.setAttribute('data-item-index', index);
                
                const cardBody = document.createElement('div');
                cardBody.className = 'card-body p-3';
                
                // Get the resolved schema for the object
                let itemSchema = arrayProperty.items;
                if (itemSchema && itemSchema.$ref) {
                    itemSchema = resolveReference(itemSchema.$ref);
                }
                
                // Create inline fields for properties
                if (itemSchema && itemSchema.properties) {
                    Object.entries(itemSchema.properties).forEach(([key, prop]) => {
                        if (key === 'id') return; // Skip ID field
                        
                        const fieldDiv = document.createElement('div');
                        fieldDiv.className = 'mb-2';
                        fieldDiv.setAttribute('data-field-name', key);
                        
                        // Create a sub-context for inline editing
                        const inlineContext = new FieldCreationContext('inline', fieldDiv);
                        const fieldElement = inlineContext.createField(key, prop, item[key]);
                        
                        // Set up change listener to update the item data
                        const input = fieldElement.querySelector('input, select, textarea');
                        if (input) {
                            // Set initial value if item has data
                            if (item[key] !== undefined) {
                                if (input.type === 'checkbox') {
                                    input.checked = item[key];
                                } else {
                                    input.value = item[key];
                                }
                            }
                            
                            input.addEventListener('change', (e) => {
                                const newValue = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
                                item[key] = newValue;
                                console.log(`Updated ${arrayName}[${index}].${key} = ${newValue}`);
                                
                                // Handle currency field dependencies for exposure metrics
                                if (key === 'quantity_kind' && newValue === 'monetary') {
                                    // Find currency field in the same card and show it
                                    const currencyField = card.querySelector('[data-field-name="currency"]');
                                    if (currencyField) {
                                        currencyField.style.display = 'block';
                                        const label = currencyField.querySelector('label');
                                        if (label && !label.innerHTML.includes('*')) {
                                            label.innerHTML += ' <span class="text-danger">*</span>';
                                        }
                                    }
                                } else if (key === 'quantity_kind' && newValue !== 'monetary') {
                                    const currencyField = card.querySelector('[data-field-name="currency"]');
                                    if (currencyField) {
                                        currencyField.style.display = 'none';
                                        const currencyInput = currencyField.querySelector('select, input');
                                        if (currencyInput) {
                                            currencyInput.value = '';
                                            item.currency = '';
                                        }
                                        const label = currencyField.querySelector('label');
                                        if (label) {
                                            label.innerHTML = label.innerHTML.replace(' <span class="text-danger">*</span>', '');
                                        }
                                    }
                                }
                            });
                        }
                        
                        fieldDiv.appendChild(fieldElement);
                        cardBody.appendChild(fieldDiv);
                    });
                }
                
                // Action buttons
                const actions = document.createElement('div');
                actions.className = 'd-flex justify-content-end gap-2 mt-2';
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-outline-danger btn-sm';
                removeBtn.textContent = '🗑️ Remove';
                removeBtn.addEventListener('click', () => {
                    arrayData.splice(index, 1);
                    renderCallback();
                });
                
                actions.appendChild(removeBtn);
                cardBody.appendChild(actions);
                
                card.appendChild(cardBody);
                
                // Handle currency field visibility after card is created
                setTimeout(() => {
                    const quantityKindField = card.querySelector('[data-field-name="quantity_kind"] select, [data-field-name="quantity_kind"] input');
                    const currencyField = card.querySelector('[data-field-name="currency"]');
                    
                    if (quantityKindField && currencyField) {
                        const currentValue = item.quantity_kind || quantityKindField.value;
                        if (currentValue === 'monetary') {
                            currencyField.style.display = 'block';
                            const label = currencyField.querySelector('label');
                            if (label && !label.innerHTML.includes('*')) {
                                label.innerHTML += ' <span class="text-danger">*</span>';
                            }
                        } else {
                            currencyField.style.display = 'none';
                        }
                    }
                }, 50);
                
                return card;
            }

            createObjectInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'object-field';

                const isDirectFormProperty = !name.includes('.') || name.split('.').length <= 2;
                const isSpatialField = name === 'spatial';
                const isGeometryField = name.endsWith('.geometry');
                const isClassificationField = name.endsWith('.se_category') || name === 'se_category';

                // Always show title for spatial field, geometry sub-field, classification fields, or for nested objects
                if (!isDirectFormProperty || isSpatialField || isGeometryField || isClassificationField) {
                    const title = document.createElement('h6');
                    title.textContent = property.title || name;
                    title.className = 'mb-3';

                    // Add some styling for main spatial section
                    if (isSpatialField) {
                        title.className = 'mb-3 mt-3';
                        title.style.borderBottom = '1px solid #dee2e6';
                        title.style.paddingBottom = '0.5rem';
                    }

                    container.appendChild(title);
                }
                
                if (property.properties) {
                    Object.entries(property.properties).forEach(([key, prop]) => {
                        const fieldValue = value && value[key] ? value[key] : null;
                        const subContext = new FieldCreationContext(this.context.type, this.context.container);
                        const field = subContext.createField(`${name}.${key}`, prop, fieldValue, options);
                        container.appendChild(field);
                    });
                }
                
                return container;
            }

            addValidationIndicator(container, name) {
                const validationIndicator = document.createElement('span');
                validationIndicator.className = 'validation-indicator';
                validationIndicator.id = `validation-${name}`;
                container.appendChild(validationIndicator);
            }

            addExamples(container, property) {
                if (property.examples && property.examples.length > 0) {
                    const hint = document.createElement('div');
                    hint.className = 'field-hint';
                    hint.innerHTML = `<strong>Examples:</strong> ${property.examples.slice(0, 3).join(', ')}`;
                    container.appendChild(hint);
                }
            }

            handleDependencies(container, name, property, value) {
                // Special handling for currency field - show only when quantity_kind is 'monetary'
                if (name.includes('currency') || name === 'currency') {
                    container.style.display = 'none';
                    // Find the related quantity_kind field name
                    let quantityKindFieldName = null;
                    if (name.includes('impact_and_losses')) {
                        // e.g. loss.impact_and_losses.currency => loss.impact_and_losses.quantity_kind
                        quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                    } else if (name.includes('metrics')) {
                        // e.g. metrics.currency => metrics.quantity_kind
                        quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                    } else if (name.includes('losses.impact_and_losses')) {
                        quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                    } else {
                        // fallback: try to find a sibling quantity_kind
                        quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                    }

                    // Helper to update visibility
                    function updateCurrencyVisibility() {
                        const qkValue = getNestedValue(currentFormData, quantityKindFieldName);
                        if (qkValue === 'monetary') {
                            container.style.display = '';
                        } else {
                            container.style.display = 'none';
                        }
                    }

                    // Initial check
                    setTimeout(updateCurrencyVisibility, 0);

                    // Listen for changes on the related quantity_kind field
                    setTimeout(() => {
                        // Try to find the input/select for quantity_kind
                        const qkInput = document.getElementById(this.context.getFieldId(quantityKindFieldName));
                        if (qkInput) {
                            qkInput.addEventListener('change', updateCurrencyVisibility);
                        }
                    }, 100);
                }
            }

            isRequiredField(name, property, options) {
                if (currentSchema.required && currentSchema.required.includes(name)) {
                    return true;
                }
                
                // Currency field is required only when impact_unit is monetary
                if (name.includes('currency') && name.includes('impact_and_losses')) {
                    const parentPath = name.replace('currency', 'impact_unit');
                    const parentValue = getNestedValue(currentFormData, parentPath);
                    return parentValue === 'monetary';
                }
                
                return false;
            }

            setupAutoComplete(input, fieldName, property) {
                let suggestions = [];
                
                if (property.suggestions && property.suggestions.length > 0) {
                    suggestions = [...property.suggestions];
                }
                
                if (property.examples && property.examples.length > 0) {
                    suggestions = [...suggestions, ...property.examples];
                }
                
                if (AUTO_COMPLETE_SUGGESTIONS[fieldName]) {
                    suggestions = [...suggestions, ...AUTO_COMPLETE_SUGGESTIONS[fieldName]];
                }
                
                suggestions = [...new Set(suggestions)];
                
                if (suggestions.length === 0) return;

                const container = input.parentElement;
                let suggestionContainer = container;
                if (container.classList.contains('input-group')) {
                    suggestionContainer = container.parentElement;
                }
                
                if (!suggestionContainer) return;
                
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions';
                suggestionContainer.appendChild(suggestionsDiv);

                input.addEventListener('input', function() {
                    const value = this.value.toLowerCase();
                    const matches = suggestions.filter(s => s.toLowerCase().includes(value));
                    
                    if (matches.length > 0 && value.length > 0) {
                        suggestionsDiv.innerHTML = '';
                        matches.slice(0, 8).forEach(match => {
                            const div = document.createElement('div');
                            div.className = 'autocomplete-suggestion';
                            div.textContent = match;
                            div.addEventListener('click', () => {
                                input.value = match;
                                suggestionsDiv.style.display = 'none';
                                updateFormData();
                            });
                            suggestionsDiv.appendChild(div);
                        });
                        suggestionsDiv.style.display = 'block';
                    } else {
                        suggestionsDiv.style.display = 'none';
                    }
                });

                input.addEventListener('blur', function() {
                    setTimeout(() => {
                        suggestionsDiv.style.display = 'none';
                    }, 150);
                });
            }
        }

        /**
         * Unified Event Handler
         * Handles events consistently across all contexts
         */
        class UnifiedEventHandler {
            constructor(context) {
                this.context = context;
            }

            setupListeners(element, name, property, options = {}) {
                const eventType = this.getEventType(element);
                
                element.addEventListener(eventType, (e) => {
                    this.handleFieldChange(e, name, property, options);
                });
            }

            getEventType(element) {
                if (element.type === 'checkbox') return 'change';
                if (element.tagName === 'SELECT') return 'change';
                return 'input';
            }

            handleFieldChange(event, name, property, options) {
                const value = this.getFieldValue(event.target);
                
                // Update form data
                if (this.context.type === 'normal') {
                    updateFormData();
                } else if (this.context.type === 'modal') {
                    // Handle modal-specific updates
                    this.handleModalFieldChange(name, value, property);
                }

                // Validate field
                this.context.validateField(name, value, property);
                
                // Handle dependencies
                this.handleDependentFields(name, value, event.target);
            }

            getFieldValue(element) {
                if (element.type === 'checkbox') return element.checked;
                return element.value;
            }

            handleModalFieldChange(name, value, property) {
                // Modal-specific data handling can be added here
                console.log(`Modal field changed: ${name} = ${value}`);
            }

            handleDependentFields(changedFieldName, newValue, element) {
                // Handle field dependencies
                const dependents = this.findDependentFields(changedFieldName);
                
                dependents.forEach(dependentFieldName => {
                    const dependentField = document.getElementById(
                        this.context.getFieldId(dependentFieldName)
                    );
                    
                    if (dependentField) {
                        if (dependentFieldName.includes('hazard_process') || dependentFieldName.includes('processes')) {
                            this.rebuildDependentDropdown(dependentField, dependentFieldName, newValue);
                        } else if (dependentFieldName.includes('currency')) {
                            this.toggleCurrencyField(dependentField, newValue);
                        }
                    }
                });

                // Special handling for impact_unit field to show/hide currency
                if (changedFieldName.includes('impact_unit') || (this.context.type === 'modal' && changedFieldName === 'impact_unit')) {
                    let currencyFieldName;
                    if (this.context.type === 'modal') {
                        currencyFieldName = 'currency';
                    } else {
                        currencyFieldName = changedFieldName.replace('impact_unit', 'currency');
                    }
                    
                    const currencyField = document.getElementById(this.context.getFieldId(currencyFieldName));
                    
                    console.log(`Impact unit changed: ${changedFieldName} = ${newValue}`);
                    console.log(`Looking for currency field: ${this.context.getFieldId(currencyFieldName)}`);
                    console.log(`Currency field found:`, !!currencyField);
                    
                    if (currencyField) {
                        this.toggleCurrencyFieldContainer(currencyField.closest('.form-field, .modal-form-field'), newValue);
                    }
                }

                // Special handling for quantity_kind field to show/hide currency
                if (changedFieldName.includes('quantity_kind') || (this.context.type === 'modal' && changedFieldName === 'quantity_kind')) {
                    let currencyFieldName;
                    if (this.context.type === 'modal') {
                        currencyFieldName = 'currency';
                    } else {
                        currencyFieldName = changedFieldName.replace('quantity_kind', 'currency');
                    }
                    
                    const currencyField = document.getElementById(this.context.getFieldId(currencyFieldName));
                    
                    console.log(`Quantity kind changed: ${changedFieldName} = ${newValue}`);
                    console.log(`Looking for currency field: ${this.context.getFieldId(currencyFieldName)}`);
                    console.log(`Currency field found:`, !!currencyField);
                    
                    if (currencyField) {
                        this.toggleCurrencyFieldContainer(currencyField.closest('.form-field, .modal-form-field'), newValue);
                    }
                }

                // Special handling for hazard type changes to update processes
                if (changedFieldName.includes('hazard_type') || changedFieldName.includes('type') || 
                    (this.context.type === 'modal' && changedFieldName === 'type')) {
                    
                    let processFieldName;
                    if (this.context.type === 'modal') {
                        processFieldName = 'processes';
                    } else if (changedFieldName.includes('hazard_type')) {
                        processFieldName = changedFieldName.replace('hazard_type', 'hazard_process');
                    } else {
                        // This covers hazards.type -> hazards.processes
                        processFieldName = changedFieldName.replace('type', 'processes');
                    }
                    
                    const processField = document.getElementById(this.context.getFieldId(processFieldName));
                    
                    console.log(`Hazard type changed: ${changedFieldName} = ${newValue}`);
                    console.log(`Looking for process field: ${this.context.getFieldId(processFieldName)}`);
                    console.log(`Process field found:`, !!processField);
                    
                    if (processField) {
                        this.rebuildDependentDropdown(processField, processFieldName, newValue);
                    }
                }
            }

            findDependentFields(parentFieldName) {
                const dependents = [];
                Object.entries(FIELD_DEPENDENCIES).forEach(([dependent, parent]) => {
                    if (parent === parentFieldName) {
                        dependents.push(dependent);
                    }
                });
                return dependents;
            }

            rebuildDependentDropdown(selectElement, fieldName, parentValue) {
                if (!parentValue) return;
                
                console.log(`Rebuilding dropdown: ${fieldName} based on parent value: ${parentValue}`);
                
                const currentValue = selectElement.value;
                
                // Clear existing options
                selectElement.innerHTML = '';
                
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select an option...';
                selectElement.appendChild(emptyOption);
                
                // Get available options based on parent value
                let availableOptions = [];
                
                if ((fieldName.includes('process') || fieldName === 'processes') && currentSchema.hazard_process_mappings) {
                    availableOptions = currentSchema.hazard_process_mappings[parentValue] || [];
                    console.log(`Found ${availableOptions.length} process options for "${parentValue}":`, availableOptions);
                }
                
                // Populate new options
                availableOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    
                    if (currentValue === option) {
                        optionElement.selected = true;
                    }
                    
                    selectElement.appendChild(optionElement);
                });
                
                // If previous selection is no longer valid, clear it
                if (currentValue && !availableOptions.includes(currentValue)) {
                    selectElement.value = '';
                    selectElement.dispatchEvent(new Event('change'));
                }
            }

            toggleCurrencyField(currencyField, impactUnitValue) {
                // This method handles the field element directly
                if (impactUnitValue === 'monetary') {
                    currencyField.style.display = 'block';
                    currencyField.required = true;
                } else {
                    currencyField.style.display = 'none';
                    currencyField.required = false;
                    currencyField.value = '';
                }
            }

            toggleCurrencyFieldContainer(container, impactUnitValue) {
                // This method handles the container (form-field div)
                const label = container.querySelector('label');
                const input = container.querySelector('select, input');
                
                if (impactUnitValue === 'monetary') {
                    container.style.display = 'block';
                    if (input) input.required = true;
                    
                    if (label && !label.innerHTML.includes('*')) {
                        label.innerHTML += ' <span class="text-danger">*</span>';
                        container.classList.add('required');
                    }
                } else {
                    container.style.display = 'none';
                    if (input) {
                        input.required = false;
                        input.value = '';
                    }
                    
                    if (label) {
                        label.innerHTML = label.innerHTML.replace(' <span class="text-danger">*</span>', '');
                        container.classList.remove('required');
                    }
                }
            }
        }

        /**
         * Unified Field Validator
         * Handles validation consistently across all contexts
         */
        class UnifiedFieldValidator {
            constructor(context) {
                this.context = context;
            }

            validate(fieldName, value, property) {
                let isValid = true;
                let errorMessage = '';

                if (currentSchema.required && currentSchema.required.includes(fieldName) && 
                    (!value || (typeof value === 'string' && value.trim() === ''))) {
                    isValid = false;
                    errorMessage = 'Required field';
                }
                
                if (value && typeof value === 'string') {
                    if (property.minLength && value.length < property.minLength) {
                        isValid = false;
                        errorMessage = `Minimum ${property.minLength} characters`;
                    }
                    if (property.format === 'email' && value && !this.isValidEmail(value)) {
                        isValid = false;
                        errorMessage = 'Invalid email format';
                    }
                    if (property.format === 'iri' && value && !this.isValidUrl(value)) {
                        isValid = false;
                        errorMessage = 'Invalid URL format';
                    }
                }

                // Only update validation indicators for normal context
                if (this.context.type === 'normal') {
                    fieldValidationStatus.set(fieldName, { isValid, errorMessage });
                    this.updateValidationIndicator(fieldName, isValid, errorMessage);
                    updateValidationDisplay();
                }
                
                return { isValid, errorMessage };
            }

            updateValidationIndicator(fieldName, isValid, errorMessage) {
                const indicator = document.getElementById(`validation-${fieldName}`);
                if (indicator) {
                    if (isValid) {
                        indicator.className = 'validation-indicator valid';
                        indicator.textContent = '✓';
                        indicator.title = 'Valid';
                    } else {
                        indicator.className = 'validation-indicator invalid';
                        indicator.textContent = '✗';
                        indicator.title = errorMessage;
                    }
                }
            }

            isValidEmail(email) {
                return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
            }

            isValidUrl(url) {
                try {
                    new URL(url);
                    return true;
                } catch {
                    return false;
                }
            }
        }

        // ================================
        // MAIN APPLICATION LOGIC
        // ================================

        // Auto-ID generation
        function generateUniqueId(prefix = 'item') {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return `${prefix}_${result}`;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            loadSchemaVersions();
            loadFromStorage();
            loadCountryNames();
            updateRiskDataType();
        });

        function setupEventListeners() {
            // Schema version selection
            document.getElementById('schemaVersionSelect').addEventListener('change', loadSelectedSchema);

            // Section checkboxes
            SECTIONS.forEach(section => {
                document.getElementById(`${section}Check`).addEventListener('change', function() {
                    if (this.checked) {
                        activeSections.add(section);
                        addSectionTab(section);
                    } else {
                        activeSections.delete(section);
                        removeSectionTab(section);
                    }
                    updateFormData();
                    updateRiskDataType();
                    generateForm();
                });
            });

            // File upload
            document.getElementById('schemaDropZone').addEventListener('click', () => 
                document.getElementById('schemaFile').click()
            );
            document.getElementById('schemaFile').addEventListener('change', handleSchemaFile);
            
            // Drag and drop
            setupDragAndDrop();

            // Buttons
            document.getElementById('exportJson').addEventListener('click', exportJson);
            document.getElementById('exportXml').addEventListener('click', exportXml);
            document.getElementById('saveProgress').addEventListener('click', saveProgress);
            document.getElementById('loadData').addEventListener('click', loadData);
            document.getElementById('validateForm').addEventListener('click', validateForm);
            document.getElementById('resetForm').addEventListener('click', resetForm);
            
            // Object editor modal
            document.getElementById('saveObjectBtn').addEventListener('click', saveCurrentObject);
        }

        function loadSchemaVersions() {
            const select = document.getElementById('schemaVersionSelect');
            select.innerHTML = '<option value="">Select RDLS version...</option>';
            
            Object.keys(RDLS_VERSIONS).forEach(version => {
                const option = document.createElement('option');
                option.value = version;
                const isLatest = version === '0.3.0';
                option.textContent = `RDLS ${version}${isLatest ? ' (latest - enhanced with combobox)' : ''}`;
                select.appendChild(option);
            });
            
            // Auto-select the latest version
            select.value = '0.3.0';
            loadSelectedSchema();
        }

        async function loadSelectedSchema() {
            const version = document.getElementById('schemaVersionSelect').value;
            if (!version) return;

            updateSchemaStatus('Loading schema...', 'text-info');
            
            try {
                const response = await fetch(RDLS_VERSIONS[version]);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                currentSchema = await response.json();
                
                // Ensure mappings are available
                if (!currentSchema.hazard_process_mappings) {
                    currentSchema.hazard_process_mappings = {
                        "drought": ["agricultural_drought", "hydrological_drought", "meteorological_drought", "socioeconomic_drought"],
                        "flood": ["fluvial_flood", "pluvial_flood", "groundwater_flood", "coastal_flood"],
                        "earthquake": ["primary_rupture", "secondary_rupture", "ground_motion", "liquefaction"],
                        "extreme_temperature": ["extreme_cold", "extreme_heat"],
                        "strong_wind": ["extratropical_cyclone", "tropical_cyclone", "tornado"],
                        "wildfire": ["wildfire"],
                        "landslide": ["snow_avalanche", "landslide_general", "landslide_rockslide", "landslide_mudflow", "landslide_rockfall"],
                        "tsunami": ["tsunami"],
                        "volcanic": ["ashfall", "volcano_ballistics", "lahar", "lava", "pyroclastic_flow"],
                        "coastal_flood": ["coastal_flood", "storm_surge"],
                        "convective_storm": ["tornado"]
                    };
                }
                
                updateSchemaStatus(`✓ RDLS ${version} loaded`, 'text-success');
                generateForm();
            } catch (error) {
                updateSchemaStatus(`✗ Failed to load schema: ${error.message}`, 'text-danger');
                console.error('Schema loading error:', error);
            }
        }

        function updateSchemaStatus(message, className) {
            const status = document.getElementById('schemaStatus');
            status.textContent = message;
            status.className = `schema-status ${className}`;
        }

        async function loadCountryNames() {
            try {
                const response = await fetch('https://restcountries.com/v3.1/all?fields=cca3,name');
                const countries = await response.json();
                countryNames = {};
                countries.forEach(country => {
                    countryNames[country.cca3] = country.name.common;
                });
            } catch (error) {
                console.warn('Could not load country names:', error);
            }
        }

        function handleSchemaFile(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        currentSchema = JSON.parse(e.target.result);
                        const isV21 = currentSchema.title && (currentSchema.title.includes('v3.0') || currentSchema.$id && currentSchema.$id.includes('0__2__1'));
                        const isV20 = currentSchema.title && (currentSchema.title.includes('v2.0') || currentSchema.$id && currentSchema.$id.includes('0__2__0'));
                        let statusMessage = '✓ Custom schema loaded';
                        
                        if (isV21) {
                            statusMessage = '✓ RDLS v3.0 schema loaded (enhanced with combobox fields)';
                        } else if (isV20) {
                            statusMessage = '✓ RDLS v2.0 schema loaded';
                        }
                        
                        updateSchemaStatus(statusMessage, 'text-success');
                        generateForm();
                    } catch (error) {
                        updateSchemaStatus('✗ Invalid JSON file', 'text-danger');
                    }
                };
                reader.readAsText(file);
            }
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('schemaDropZone');
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    document.getElementById('schemaFile').files = files;
                    handleSchemaFile({target: {files: files}});
                }
            });
        }

        function addSectionTab(section) {
            const tabsContainer = document.getElementById('metadataTabs');
            const contentContainer = document.getElementById('metadataTabContent');
            
            tabsContainer.style.display = 'flex';
            
            const tabButton = document.createElement('li');
            tabButton.className = 'nav-item';
            tabButton.setAttribute('role', 'presentation');
            tabButton.innerHTML = `
                <button class="nav-link ${section}-tab" id="${section}-tab" data-bs-toggle="tab" 
                        data-bs-target="#${section}" type="button" role="tab">
                    ${section.charAt(0).toUpperCase() + section.slice(1)}
                </button>
            `;
            tabsContainer.appendChild(tabButton);
            
            const tabContent = document.createElement('div');
            tabContent.className = 'tab-pane fade';
            tabContent.id = section;
            tabContent.setAttribute('role', 'tabpanel');
            tabContent.innerHTML = `<div id="${section}Form"></div>`;
            contentContainer.appendChild(tabContent);
        }

        function removeSectionTab(section) {
            const tabButton = document.getElementById(`${section}-tab`);
            if (tabButton) tabButton.parentElement.remove();
            
            const tabContent = document.getElementById(section);
            if (tabContent) tabContent.remove();
            
            if (activeSections.size === 1) {
                document.getElementById('metadataTabs').style.display = 'none';
            }
        }

        function generateForm() {
            if (!currentSchema) {
                updateFormStatus('warning', 'No schema loaded');
                return;
            }

            try {
                // Initialize array-type fields if they don't exist
                if (currentSchema.properties) {
                    Object.entries(currentSchema.properties).forEach(([key, property]) => {
                        if (property.type === 'array' && !currentFormData[key]) {
                            currentFormData[key] = [];
                        }
                    });
                }

                document.getElementById('metadataForm').innerHTML = '';
                SECTIONS.forEach(section => {
                    const sectionForm = document.getElementById(`${section}Form`);
                    if (sectionForm) sectionForm.innerHTML = '';
                });

                fieldValidationStatus.clear();

                generateSectionForm('general', currentSchema.properties, 'metadataForm');
                
                activeSections.forEach(section => {
                    if (section !== 'general' && currentSchema.properties[section]) {
                        const sectionSchema = currentSchema.properties[section];
                        if (sectionSchema.type === 'array') {
                            generateSectionForm(section, null, `${section}Form`);
                        } else {
                            generateSectionForm(section, sectionSchema.properties, `${section}Form`);
                        }
                    }
                });

                updateFormStatus('success', 'RDLS Form Ready');
                updatePreview();
                updateValidationDisplay();

            } catch (error) {
                updateFormStatus('danger', 'Generation Error: ' + error.message);
                console.error('Form generation error:', error);
            }
        }

        function generateSectionForm(sectionName, properties, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const form = document.createElement('form');
            form.className = 'needs-validation';
            form.noValidate = true;
            
            form.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const inputs = form.querySelectorAll('input, select, textarea');
                    const currentIndex = Array.from(inputs).indexOf(event.target);
                    if (currentIndex < inputs.length - 1) {
                        inputs[currentIndex + 1].focus();
                    }
                }
            });

            const title = document.createElement('h5');
            title.textContent = `${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)} Metadata`;
            title.className = 'mb-3 mt-3';
            form.appendChild(title);

            // Create unified context for normal form fields
            const context = new FieldCreationContext('normal', form);

            if (sectionName === 'general') {
                const requiredRoles = ['publisher', 'creator', 'contact_point'];

                // First, add all non-attribution fields
                Object.entries(properties).forEach(([key, property]) => {
                    if (!SECTIONS.includes(key) && key !== 'links' && key !== 'risk_data_type' && key !== 'attributions') {
                        const existingValue = currentFormData[key];
                        const fieldElement = context.createField(key, property, existingValue);
                        form.appendChild(fieldElement);
                    }
                });

                // Create Attribution section
                const attributionSection = document.createElement('div');
                attributionSection.className = 'card mb-4';

                const attributionHeader = document.createElement('div');
                attributionHeader.className = 'card-header';
                attributionHeader.innerHTML = '<h6 class="mb-0">Attribution</h6>';

                const attributionBody = document.createElement('div');
                attributionBody.className = 'card-body';

                // Initialize attributions array if it doesn't exist
                if (!currentFormData.attributions) {
                    currentFormData.attributions = [];
                }

                // Function to render attribution list
                const renderAttributionList = () => {
                    // Clear existing content
                    attributionBody.innerHTML = '';

                    const currentAttributions = currentFormData.attributions || [];

                    // Get mandatory attributions
                    const mandatoryAttributions = currentAttributions.filter(attr =>
                        requiredRoles.includes(attr.role)
                    );

                    // Get additional attributions
                    const additionalAttributions = currentAttributions.filter(attr =>
                        !requiredRoles.includes(attr.role)
                    );

                    // Show mandatory attributions as inline summaries
                    requiredRoles.forEach(role => {
                        const existingAttr = mandatoryAttributions.find(attr => attr.role === role);

                        const attrDiv = document.createElement('div');
                        attrDiv.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';

                        if (existingAttr) {
                            attrDiv.innerHTML = `
                                <div>
                                    <strong>${role.replace('_', ' ').toUpperCase()}</strong><br>
                                    <small class="text-muted">${existingAttr.entity?.name || 'Unnamed entity'}</small>
                                </div>
                                <div>
                                    <button type="button" class="btn btn-sm btn-outline-primary me-1" onclick="editAttribution('${existingAttr.id}')">Edit</button>
                                    <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteAttribution('${existingAttr.id}')">Delete</button>
                                </div>
                            `;
                        } else {
                            attrDiv.innerHTML = `
                                <div>
                                    <strong>${role.replace('_', ' ').toUpperCase()}</strong><br>
                                    <small class="text-danger">Required - Not set</small>
                                </div>
                                <div>
                                    <button type="button" class="btn btn-sm btn-primary" onclick="addRequiredAttribution('${role}')">Add</button>
                                </div>
                            `;
                        }

                        attributionBody.appendChild(attrDiv);
                    });

                    // Show additional attributions
                    additionalAttributions.forEach(attr => {
                        const attrDiv = document.createElement('div');
                        attrDiv.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded bg-light';
                        attrDiv.innerHTML = `
                            <div>
                                <strong>${attr.role.replace('_', ' ').toUpperCase()}</strong><br>
                                <small class="text-muted">${attr.entity?.name || 'Unnamed entity'}</small>
                            </div>
                            <div>
                                <button type="button" class="btn btn-sm btn-outline-primary me-1" onclick="editAttribution('${attr.id}')">Edit</button>
                                <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteAttribution('${attr.id}')">Delete</button>
                            </div>
                        `;
                        attributionBody.appendChild(attrDiv);
                    });

                    // Add "Add More Attribution" button
                    const addButton = document.createElement('button');
                    addButton.type = 'button';
                    addButton.className = 'btn btn-outline-secondary mt-3';
                    addButton.innerHTML = '+ Add More Attribution';
                    addButton.addEventListener('click', function() {
                        addNewAttribution();
                    });
                    attributionBody.appendChild(addButton);
                };

                // Global functions for attribution management
                window.editAttribution = (attrId) => {
                    const attribution = currentFormData.attributions.find(attr => attr.id === attrId);
                    if (attribution) {
                        const index = currentFormData.attributions.indexOf(attribution);
                        openObjectEditor('attributions', index, properties.attributions.items, currentFormData.attributions, renderAttributionList);
                    }
                };

                window.deleteAttribution = (attrId) => {
                    if (confirm('Are you sure you want to delete this attribution?')) {
                        currentFormData.attributions = currentFormData.attributions.filter(attr => attr.id !== attrId);
                        renderAttributionList();
                    }
                };

                window.addRequiredAttribution = (role) => {
                    const newId = `attribution_${role}_${Date.now()}`;
                    const newAttribution = {
                        id: newId,
                        role: role,
                        entity: {}
                    };
                    currentFormData.attributions.push(newAttribution);
                    const index = currentFormData.attributions.length - 1;
                    openObjectEditor('attributions', index, properties.attributions.items, currentFormData.attributions, renderAttributionList);
                };

                window.addNewAttribution = () => {
                    const newId = `attribution_${Date.now()}`;
                    const newAttribution = {
                        id: newId,
                        role: '',
                        entity: {}
                    };
                    currentFormData.attributions.push(newAttribution);
                    const index = currentFormData.attributions.length - 1;
                    openObjectEditor('attributions', index, properties.attributions.items, currentFormData.attributions, renderAttributionList);
                };

                // Initial render
                renderAttributionList();

                attributionSection.appendChild(attributionHeader);
                attributionSection.appendChild(attributionBody);
                form.appendChild(attributionSection);
            } else {
                // Check if this section is an array type (like the new exposure structure)
                const sectionSchema = currentSchema.properties[sectionName];
                if (sectionSchema && sectionSchema.type === 'array') {
                    // Handle array-type sections (like exposure)
                    const existingValue = currentFormData[sectionName];
                    const fieldElement = context.createField(sectionName, sectionSchema, existingValue);
                    form.appendChild(fieldElement);
                } else if (properties) {
                    // Handle object-type sections (like vulnerability, loss, hazard)
                    Object.entries(properties).forEach(([key, property]) => {
                        const existingValue = currentFormData[sectionName] && currentFormData[sectionName][key];
                        const fieldElement = context.createField(`${sectionName}.${key}`, property, existingValue);
                        form.appendChild(fieldElement);
                    });
                }
            }

            container.appendChild(form);
        }

        function resolveReference(ref) {
            if (!ref.startsWith('#/$defs/')) return null;
            
            const path = ref.replace('#/$defs/', '').split('/');
            let current = currentSchema.$defs;
            
            for (const segment of path) {
                if (current && current[segment] !== undefined) {
                    current = current[segment];
                } else {
                    return null;
                }
            }
            
            return current;
        }

        function parseMarkdownLinks(text) {
            if (!text) return text;
            
            const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
            
            return text.replace(markdownLinkRegex, function(match, linkText, url) {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="text-primary text-decoration-none">${linkText} <small>↗</small></a>`;
            });
        }

        function getNestedValue(obj, path) {
            const keys = path.split('.');
            let current = obj;
            
            for (const key of keys) {
                if (current && current[key] !== undefined) {
                    current = current[key];
                } else {
                    return null;
                }
            }
            
            return current;
        }

        function setNestedValue(obj, path, value) {
            const keys = path.split('.');
            let current = obj;
            
            for (let i = 0; i < keys.length - 1; i++) {
                if (!current[keys[i]]) current[keys[i]] = {};
                current = current[keys[i]];
            }
            
            current[keys[keys.length - 1]] = value;
        }

        function openObjectEditor(arrayName, objectIndex, objectSchema, arrayData, renderCallback) {
            if (objectSchema.$ref) {
            objectSchema = resolveReference(objectSchema.$ref);
            }

            currentObjectEditor = {
            arrayName: arrayName,
            objectIndex: objectIndex,
            objectSchema: objectSchema,
            arrayData: arrayData,
            renderCallback: renderCallback
            };

            const modalTitle = document.getElementById('objectEditorModalLabel');
            modalTitle.textContent = `Edit ${objectSchema.title || arrayName}`;

            // Always use the latest array data from currentFormData if available
            const fullArrayData = getNestedValue(currentFormData, arrayName) || [];
            // Preload the object data from the array if it exists
            // Only clone the object if editing, otherwise use empty object for new
            let objectData = {};
            if (typeof objectIndex === 'number' && fullArrayData[objectIndex]) {
            objectData = { ...fullArrayData[objectIndex] };
            }

            const fieldsContainer = document.getElementById('objectEditorFields');
            fieldsContainer.innerHTML = '';

            // Create unified context for modal fields
            const modalContext = new FieldCreationContext('modal', fieldsContainer);

            if (objectSchema.properties) {
            Object.entries(objectSchema.properties).forEach(([key, property]) => {
                // If this property is an array, allow editing its items inline
                if (property.type === 'array') {
                // Use the array from objectData if present, ensuring we maintain existing data
                let arrayValue = objectData[key];
                if (!Array.isArray(arrayValue)) {
                    arrayValue = [];
                    // Initialize the array in objectData so changes are tracked
                    objectData[key] = arrayValue;
                }
                const arrayField = modalContext.createField(key, property, arrayValue);
                fieldsContainer.appendChild(arrayField);
                } else {
                // For non-array properties, use the existing value from objectData
                const fieldElement = modalContext.createField(key, property, objectData[key]);
                fieldsContainer.appendChild(fieldElement);
                }
            });
            }

            const form = document.getElementById('objectEditorForm');
                        form.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const inputs = form.querySelectorAll('input, select, textarea');
                const currentIndex = Array.from(inputs).indexOf(event.target);
                if (currentIndex < inputs.length - 1) {
                inputs[currentIndex + 1].focus();
                } else {
                document.getElementById('saveObjectBtn').click();
                }
            }
            });

            const modal = new bootstrap.Modal(document.getElementById('objectEditorModal'));
            modal.show();
        }

        function createObjectSummaryCard(objectData, index, arrayName, arrayProperty) {
            const card = document.createElement('div');
            card.className = 'object-summary-card';
            
            let objectSchema = arrayProperty.items;
            if (objectSchema.$ref) {
                objectSchema = resolveReference(objectSchema.$ref);
            }
            
            const title = document.createElement('div');
            title.className = 'object-summary-title';
            
            let summaryText = `${arrayProperty.title || arrayName} ${index + 1}`;
            if (objectData) {
                if ((arrayName.includes('metric') || arrayName.includes('cost')) && objectData.dimension) {
                    summaryText = `${objectData.dimension.charAt(0).toUpperCase() + objectData.dimension.slice(1)} ${arrayProperty.title || arrayName}`;
                } else if (arrayName.includes('exposure') && objectData.category) {
                    summaryText = `${objectData.category.charAt(0).toUpperCase() + objectData.category.slice(1)} Exposure`;              
                } else if (arrayName.includes('event_sets') && objectData.hazards && objectData.hazards.length > 0) {
                    const hazard = objectData.hazards[0];
                    let hazardDisplay = hazard.type ? hazard.type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Hazard';
                    if (hazard.processes && hazard.processes.length > 0) {
                        const process = hazard.processes[0].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        hazardDisplay += ` / ${process}`;
                    }
                    summaryText = hazardDisplay;
                } else if (arrayName.includes('losses') && objectData.hazard_type) {
                    summaryText = objectData.hazard_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) + ' Loss';
                } else if (objectData.name) {
                    summaryText = objectData.name;
                } else if (objectData.title) {
                    summaryText = objectData.title;
                } else if (objectData.id) {
                    summaryText = objectData.id;
                }
            }
            title.textContent = summaryText;
            
            const details = document.createElement('div');
            details.className = 'object-summary-details';
            
            if (objectData) {
                let keyFields = [];
                
                if (arrayName.includes('exposure')) {
                    if (objectData.taxonomy) {
                        keyFields.push(`taxonomy: ${objectData.taxonomy}`);
                    }
                    if (objectData.metrics && objectData.metrics.length > 0) {
                        const metricCount = objectData.metrics.length;
                        keyFields.push(`metrics: ${metricCount} metric${metricCount !== 1 ? 's' : ''}`);
                    }
                }
                
                if (arrayName.includes('metric') && objectData.quantity_kind) {
                    keyFields.push(`quantity: ${objectData.quantity_kind}`);
                }
                
                if (arrayName.includes('cost') && objectData.unit) {
                    keyFields.push(`unit: ${objectData.unit}`);
                }
                
                if (arrayName.includes('event_sets')) {
                    if (objectData.analysis_type) {
                        keyFields.push(`analysis: ${objectData.analysis_type}`);
                    }
                    if (objectData.event_count) {
                        keyFields.push(`events: ${objectData.event_count}`);
                    }
                    if (objectData.occurrence_range) {
                        keyFields.push(`range: ${objectData.occurrence_range}`);
                    }
                }
                
                if (arrayName.includes('losses')) {
                    if (objectData.hazard_process) {
                        keyFields.push(`process: ${objectData.hazard_process.replace(/_/g, ' ')}`);
                    }
                    if (objectData.category) {
                        keyFields.push(`category: ${objectData.category}`);
                    }
                    if (objectData.type) {
                        keyFields.push(`type: ${objectData.type}`);
                    }
                }
                
                const otherFields = ['description', 'format', 'role', 'url'].filter(field => 
                    objectData[field] && !keyFields.some(kf => kf.includes(field))
                );
                keyFields = keyFields.concat(otherFields.map(field => `${field}: ${objectData[field]}`));
                
                if (keyFields.length > 0) {
                    details.textContent = keyFields.join(' • ');
                } else {
                    details.textContent = 'Click Edit to add details';
                }
            } else {
                details.textContent = 'New object - click Edit to configure';
            }
            
            const actions = document.createElement('div');
            actions.className = 'd-flex gap-2 mt-2';
            
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'btn btn-outline-primary btn-sm';
            editBtn.textContent = '✏️ Edit';
            editBtn.addEventListener('click', () => {
                openObjectEditor(arrayName, index, arrayProperty.items, null, null);
            });
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'btn btn-outline-danger btn-sm';
            removeBtn.textContent = '🗑️ Remove';
            removeBtn.addEventListener('click', () => {
                if (confirm(`Remove this ${arrayProperty.title || arrayName}?`)) {
                    const fullArrayData = getNestedValue(currentFormData, arrayName) || [];
                    fullArrayData.splice(index, 1);
                    setNestedValue(currentFormData, arrayName, fullArrayData);
                    updateFormData();
                    generateForm();
                }
            });
            
            actions.appendChild(editBtn);
            actions.appendChild(removeBtn);
            
            card.appendChild(title);
            card.appendChild(details);
            card.appendChild(actions);
            
            return card;
        }

        function saveCurrentObject() {
            const form = document.getElementById('objectEditorForm');
            const formData = new FormData(form);
            
            // Start with the existing object data to preserve arrays that were modified
            let objectData = {};
            
            // First, get any existing object data to preserve arrays
            const fullArrayData = getNestedValue(currentFormData, currentObjectEditor.arrayName) || [];
            if (typeof currentObjectEditor.objectIndex === 'number' && fullArrayData[currentObjectEditor.objectIndex]) {
                // Copy existing object data, including any arrays that were modified in the modal
                objectData = JSON.parse(JSON.stringify(fullArrayData[currentObjectEditor.objectIndex]));
            }
            
            // Now we need to get the current state of any array fields that were edited in the modal
            // Find all array containers in the modal and extract their current data
            const arrayContainers = document.querySelectorAll('#objectEditorFields .array-field');
            arrayContainers.forEach(container => {
                const containerId = container.querySelector('[id$="_items"]')?.id;
                if (containerId) {
                    const fieldName = containerId.replace('modal_', '').replace('_items', '');
                    const cards = container.querySelectorAll('.card[data-item-index]');
                    const arrayData = [];
                    
                    cards.forEach((card, index) => {
                        const item = {};
                        const fieldDivs = card.querySelectorAll('[data-field-name]');
                        
                        fieldDivs.forEach(fieldDiv => {
                            const fieldNameAttr = fieldDiv.getAttribute('data-field-name');
                            if (fieldNameAttr && fieldNameAttr !== 'id') {
                                const input = fieldDiv.querySelector('input, select, textarea');
                                if (input) {
                                    if (input.type === 'checkbox') {
                                        item[fieldNameAttr] = input.checked;
                                    } else {
                                        item[fieldNameAttr] = input.value;
                                    }
                                }
                            }
                        });
                        
                        // Handle bbox fields specially - they have names like fieldName_0, fieldName_1, etc.
                        const bboxInputs = card.querySelectorAll('input[name$="_0"], input[name$="_1"], input[name$="_2"], input[name$="_3"]');
                        const bboxGroups = {};
                        bboxInputs.forEach(input => {
                            const match = input.name.match(/(.+)_(\d+)$/);
                            if (match) {
                                const fieldName = match[1].replace('modal_', '');
                                const index = parseInt(match[2]);
                                if (!bboxGroups[fieldName]) bboxGroups[fieldName] = [];
                                bboxGroups[fieldName][index] = parseFloat(input.value) || 0;
                            }
                        });
                        
                        // Add bbox arrays to the item
                        Object.entries(bboxGroups).forEach(([fieldName, values]) => {
                            item[fieldName] = values;
                        });
                        
                        // Preserve the ID if it exists
                        if (objectData[fieldName] && objectData[fieldName][index] && objectData[fieldName][index].id) {
                            item.id = objectData[fieldName][index].id;
                        } else {
                            // Generate a new ID if needed
                            let idPrefix = 'item';
                            if (fieldName === 'metrics') idPrefix = 'metric';
                            else if (fieldName === 'cost') idPrefix = 'cost';
                            else if (fieldName === 'hazards') idPrefix = 'hazard';
                            item.id = generateUniqueId(idPrefix);
                        }
                        
                        arrayData.push(item);
                    });
                    
                    // Update the object data with the current array state
                    objectData[fieldName] = arrayData;
                }
            });
            
            // Collect regular form data (this will override any simple field values)
            for (let [key, value] of formData.entries()) {
                const fieldName = key.replace('modal_', '');
                
                if (fieldName.includes('.')) {
                    setNestedValue(objectData, fieldName, value);
                } else {
                    // Don't override array fields that we just processed above
                    const isArrayField = document.querySelector(`#objectEditorFields .array-field [id="modal_${fieldName}_items"]`);
                    if (!isArrayField) {
                        objectData[fieldName] = value;
                    }
                }
            }
            
            // Collect checkbox data
            const checkboxes = form.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const fieldName = cb.name.replace('modal_', '');
                if (fieldName.includes('.')) {
                    setNestedValue(objectData, fieldName, cb.checked);
                } else {
                    // Don't override array fields that we just processed above
                    const isArrayField = document.querySelector(`#objectEditorFields .array-field [id="modal_${fieldName}_items"]`);
                    if (!isArrayField) {
                        objectData[fieldName] = cb.checked;
                    }
                }
            });
            
            // Handle bbox fields in the main form (not inside array containers)
            const bboxInputs = form.querySelectorAll('input[name$="_0"], input[name$="_1"], input[name$="_2"], input[name$="_3"]');
            const bboxGroups = {};
            bboxInputs.forEach(input => {
                // Skip if this bbox input is inside an array container (already handled above)
                const isInArrayContainer = input.closest('.array-field');
                if (!isInArrayContainer) {
                    const match = input.name.match(/(.+)_(\d+)$/);
                    if (match) {
                        const fieldName = match[1].replace('modal_', '');
                        const index = parseInt(match[2]);
                        if (!bboxGroups[fieldName]) bboxGroups[fieldName] = [];
                        bboxGroups[fieldName][index] = parseFloat(input.value) || 0;
                    }
                }
            });
            
            // Add bbox arrays to the object data
            Object.entries(bboxGroups).forEach(([fieldName, values]) => {
                if (fieldName.includes('.')) {
                    setNestedValue(objectData, fieldName, values);
                } else {
                    objectData[fieldName] = values;
                }
            });
            
            // Get the full array data and update/add the object
            let fullArrayDataUpdated = getNestedValue(currentFormData, currentObjectEditor.arrayName);
            if (!fullArrayDataUpdated) {
                fullArrayDataUpdated = [];
                setNestedValue(currentFormData, currentObjectEditor.arrayName, fullArrayDataUpdated);
            }
            
            // Ensure the object has an ID
            if (currentObjectEditor.objectIndex >= fullArrayDataUpdated.length) {
                let idPrefix = 'item';
                if (currentObjectEditor.arrayName === 'resources') idPrefix = 'resource';
                else if (currentObjectEditor.arrayName === 'sources') idPrefix = 'source';
                else if (currentObjectEditor.arrayName === 'attributions') idPrefix = 'attribution';
                else if (currentObjectEditor.arrayName === 'referenced_by') idPrefix = 'reference';
                else if (currentObjectEditor.arrayName.includes('event_sets')) idPrefix = 'event_set';
                else if (currentObjectEditor.arrayName.includes('losses')) idPrefix = 'loss';
                
                objectData.id = generateUniqueId(idPrefix);
            } else {
                const existingObject = fullArrayDataUpdated[currentObjectEditor.objectIndex];
                if (existingObject && existingObject.id) {
                    objectData.id = existingObject.id;
                } else {
                    let idPrefix = 'item';
                    if (currentObjectEditor.arrayName === 'resources') idPrefix = 'resource';
                    else if (currentObjectEditor.arrayName === 'sources') idPrefix = 'source';
                    else if (currentObjectEditor.arrayName === 'attributions') idPrefix = 'attribution';
                    else if (currentObjectEditor.arrayName === 'referenced_by') idPrefix = 'reference';
                    else if (currentObjectEditor.arrayName.includes('event_sets')) idPrefix = 'event_set';
                    else if (currentObjectEditor.arrayName.includes('losses')) idPrefix = 'loss';
                    
                    objectData.id = generateUniqueId(idPrefix);
                }
            }
            
            // Update the array
            if (currentObjectEditor.objectIndex >= fullArrayDataUpdated.length) {
                fullArrayDataUpdated.push(objectData);
            } else {
                fullArrayDataUpdated[currentObjectEditor.objectIndex] = objectData;
            }
            
            setNestedValue(currentFormData, currentObjectEditor.arrayName, fullArrayDataUpdated);
            updatePreview();
            generateForm();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('objectEditorModal'));
            modal.hide();
            
            updateFormStatus('success', 'Object saved successfully');
        }

        function updateValidationDisplay() {
            const totalFields = fieldValidationStatus.size;
            const validFields = Array.from(fieldValidationStatus.values()).filter(status => status.isValid).length;
            
            const progressBar = document.getElementById('validationProgress');
            const progressPercent = totalFields > 0 ? (validFields / totalFields) * 100 : 0;
            progressBar.style.width = `${progressPercent}%`;
            
            document.getElementById('validFieldCount').textContent = validFields;
            document.getElementById('totalFieldCount').textContent = totalFields;
            
            const overallStatus = document.getElementById('overallValidation');
            if (totalFields === 0) {
                overallStatus.className = 'badge bg-secondary';
                overallStatus.textContent = 'Not validated';
            } else if (validFields === totalFields) {
                overallStatus.className = 'badge bg-success';
                overallStatus.textContent = 'All valid';
            } else {
                overallStatus.className = 'badge bg-warning';
                overallStatus.textContent = `${validFields}/${totalFields} valid`;
            }
        }

        function updateFormData() {
            const allForms = document.querySelectorAll('#metadataTabContent form');
            const newFormData = {};
            
            allForms.forEach(form => {
                const formData = new FormData(form);
                
                for (let [key, value] of formData.entries()) {
                    if (!key.includes('_0') && !key.includes('_1') && !key.includes('_2') && !key.includes('_3')) {
                        setNestedValue(newFormData, key, value);
                    }
                }
                
                const checkboxes = form.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    setNestedValue(newFormData, cb.name, cb.checked);
                });
                
                const bboxFields = form.querySelectorAll('input[name*="_0"], input[name*="_1"], input[name*="_2"], input[name*="_3"]');
                const bboxGroups = {};
                bboxFields.forEach(input => {
                    const match = input.name.match(/(.+)_(\d+)$/);
                    if (match) {
                        const fieldName = match[1];
                        const index = parseInt(match[2]);
                        if (!bboxGroups[fieldName]) bboxGroups[fieldName] = [];
                        bboxGroups[fieldName][index] = parseFloat(input.value) || 0;
                    }
                });
                
                Object.entries(bboxGroups).forEach(([fieldName, values]) => {
                    setNestedValue(newFormData, fieldName, values);
                });
            });
            
            // Preserve existing array-type fields that shouldn't be overwritten by form data
            const arrayFields = ['resources', 'sources', 'attributions', 'referenced_by', 'exposure'];
            arrayFields.forEach(fieldName => {
                if (currentFormData[fieldName] && Array.isArray(currentFormData[fieldName])) {
                    newFormData[fieldName] = currentFormData[fieldName];
                }
            });
            
            // Merge form data, but preserve array structure for known array fields
            Object.keys(newFormData).forEach(key => {
                if (currentSchema && currentSchema.properties && currentSchema.properties[key]) {
                    const fieldSchema = currentSchema.properties[key];
                    if (fieldSchema.type === 'array') {
                        if (Array.isArray(newFormData[key]) || !currentFormData[key]) {
                            currentFormData[key] = newFormData[key];
                        } else if (!Array.isArray(newFormData[key]) && Array.isArray(currentFormData[key])) {
                            console.warn(`Ignoring non-array value for array field ${key}:`, typeof newFormData[key], newFormData[key]);
                        }
                    } else {
                        currentFormData[key] = newFormData[key];
                    }
                } else {
                    currentFormData[key] = newFormData[key];
                }
            });
            
            updatePreview();
            autoSave();
        }

        function updatePreview() {
            document.getElementById('outputPreview').textContent = JSON.stringify(currentFormData, null, 2);
        }

        function updateFormStatus(type, message) {
            const status = document.getElementById('formStatus');
            status.className = `badge bg-${type}`;
            status.textContent = message;
        }

        function updateRiskDataType() {
            // Automatically set risk_data_type based on checked sections
            const riskDataTypes = [];

            SECTIONS.forEach(section => {
                const checkbox = document.getElementById(`${section}Check`);
                if (checkbox && checkbox.checked) {
                    riskDataTypes.push(section);
                }
            });

            // Always ensure risk_data_type is an array and update currentFormData
            currentFormData.risk_data_type = riskDataTypes;
        }

        function validateForm() {
            updateFormData();
            
            const allInputs = document.querySelectorAll('#metadataTabContent input, #metadataTabContent select, #metadataTabContent textarea');
            allInputs.forEach(input => {
                if (input.name) {
                    const property = getPropertyFromSchema(input.name);
                    if (property) {
                        const value = input.type === 'checkbox' ? input.checked : input.value;
                        const context = new FieldCreationContext('normal');
                        context.validateField(input.name, value, property);
                    }
                }
            });
            
            const totalFields = fieldValidationStatus.size;
            const validFields = Array.from(fieldValidationStatus.values()).filter(status => status.isValid).length;
            
            if (validFields === totalFields && totalFields > 0) {
                updateFormStatus('success', 'RDLS Compliant ✓');
                alert('✅ All fields are valid! Your metadata is RDLS compliant.');
            } else {
                const invalidFields = Array.from(fieldValidationStatus.entries())
                    .filter(([name, status]) => !status.isValid)
                    .map(([name, status]) => `${name}: ${status.errorMessage}`);
                updateFormStatus('warning', `${validFields}/${totalFields} valid`);
                alert(`⚠️ ${invalidFields.length} field(s) need attention:\n\n• ${invalidFields.join('\n• ')}`);
            }
        }

        function getPropertyFromSchema(fieldName) {
            if (!currentSchema) return null;
            
            const parts = fieldName.split('.');
            let current = currentSchema.properties;
            
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                
                if (current && current[part]) {
                    if (i === parts.length - 1) {
                        if (current[part].$ref) {
                            return resolveReference(current[part].$ref);
                        }
                        return current[part];
                    } else {
                        if (current[part].properties) {
                            current = current[part].properties;
                        } else if (current[part].$ref) {
                            const resolved = resolveReference(current[part].$ref);
                            if (resolved && resolved.properties) {
                                current = resolved.properties;
                            } else {
                                return current[part];
                            }
                        } else {
                            return null;
                        }
                    }
                } else {
                    return null;
                }
            }
            
            return current;
        }

        function exportJson() {
            if (Object.keys(currentFormData).length === 0) {
                alert('No data to export. Please fill out the form first.');
                return;
            }
            
            const blob = new Blob([JSON.stringify(currentFormData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'rdls_metadata.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportXml() {
            if (Object.keys(currentFormData).length === 0) {
                alert('No data to export. Please fill out the form first.');
                return;
            }
            
            const xml = jsonToXml(currentFormData, 'rdls_dataset');
            const blob = new Blob([xml], {type: 'application/xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'rdls_metadata.xml';
            a.click();
            URL.revokeObjectURL(url);
        }

        function jsonToXml(obj, rootName = 'root') {
            let xml = `<?xml version="1.0" encoding="UTF-8"?>\n<${rootName}>\n`;
            
            function objectToXml(obj, indent = '  ') {
                let result = '';
                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        value.forEach(item => {
                            result += `${indent}<${key}>${escapeXml(item)}</${key}>\n`;
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        result += `${indent}<${key}>\n${objectToXml(value, indent + '  ')}${indent}</${key}>\n`;
                    } else {
                        result += `${indent}<${key}>${escapeXml(value)}</${key}>\n`;
                    }
                }
                return result;
            }
            
            xml += objectToXml(obj);
            xml += `</${rootName}>`;
            return xml;
        }

        function escapeXml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function autoSave() {
            localStorage.setItem('rdlsEditor_formData', JSON.stringify(currentFormData));
            localStorage.setItem('rdlsEditor_activeSections', JSON.stringify([...activeSections]));
        }

        function loadFromStorage() {
            const savedData = localStorage.getItem('rdlsEditor_formData');
            const savedSections = localStorage.getItem('rdlsEditor_activeSections');
            
            if (savedData) {
                try {
                    currentFormData = JSON.parse(savedData);
                    updatePreview();
                } catch (e) {
                    console.warn('Could not load saved form data');
                }
            }
            
            if (savedSections) {
                try {
                    const sections = JSON.parse(savedSections);
                    sections.forEach(section => {
                        if (section !== 'general') {
                            activeSections.add(section);
                            document.getElementById(`${section}Check`).checked = true;
                            addSectionTab(section);
                        }
                    });
                } catch (e) {
                    console.warn('Could not load saved sections');
                }
            }
        }

        function saveProgress() {
            autoSave();
            alert('Progress saved to browser storage!');
        }

        // Migration function to convert old attribution format to new format
        function migrateAttributionData(data) {
            const oldFields = ['publisher', 'creator', 'contact_point'];
            const migratedData = { ...data };

            // Initialize attributions array if it doesn't exist
            if (!migratedData.attributions) {
                migratedData.attributions = [];
            }

            // Migrate old fields to attributions array
            oldFields.forEach(fieldName => {
                if (migratedData[fieldName] && typeof migratedData[fieldName] === 'object') {
                    // Check if this attribution doesn't already exist
                    const existingAttribution = migratedData.attributions.find(attr => attr.role === fieldName);

                    if (!existingAttribution) {
                        const newAttribution = {
                            id: `attribution_${fieldName}_migrated_${Date.now()}`,
                            role: fieldName,
                            entity: migratedData[fieldName]
                        };
                        migratedData.attributions.push(newAttribution);
                    }

                    // Remove the old field
                    delete migratedData[fieldName];
                }
            });

            return migratedData;
        }

        function loadData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            let loadedData = JSON.parse(event.target.result);

                            // Migrate attribution data from old format to new format
                            loadedData = migrateAttributionData(loadedData);

                            currentFormData = loadedData;
                            updatePreview();
                            generateForm();
                        } catch (error) {
                            alert('Invalid JSON file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function resetForm() {
            if (confirm('Are you sure you want to reset all data? This will clear all form fields and cannot be undone.')) {
                // Clear form data
                currentFormData = {};
                
                // Clear validation status
                fieldValidationStatus.clear();
                
                // Reset active sections to just general
                activeSections.clear();
                activeSections.add('general');
                
                // Uncheck all section checkboxes except general
                SECTIONS.forEach(section => {
                    const checkbox = document.getElementById(`${section}Check`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                });
                
                // Remove all section tabs except general
                SECTIONS.forEach(section => {
                    removeSectionTab(section);
                });
                
                // Hide tabs if only general is active
                document.getElementById('metadataTabs').style.display = 'none';
                
                // Clear localStorage
                localStorage.removeItem('rdlsEditor_formData');
                localStorage.removeItem('rdlsEditor_activeSections');
                
                // Clear preview
                document.getElementById('outputPreview').textContent = JSON.stringify({
                    "message": "Refactored RDLS metadata will appear here..."
                }, null, 2);
                
                // Reset validation display
                document.getElementById('validFieldCount').textContent = '0';
                document.getElementById('totalFieldCount').textContent = '0';
                document.getElementById('validationProgress').style.width = '0%';
                document.getElementById('overallValidation').className = 'badge bg-secondary';
                document.getElementById('overallValidation').textContent = 'Not validated';
                
                // Regenerate form
                if (currentSchema) {
                    generateForm();
                    updateFormStatus('info', 'Form Reset Complete');
                }
                
                // Show success message
                alert('✅ All data has been reset! The form is now back to its initial state.');
            }
        }

        // ================================
        // TESTING AND DEBUGGING FUNCTIONS
        // ================================

        function testUnifiedSystem() {
            console.log('=== Testing Unified Field Creation System ===');
            console.log('Schema loaded:', !!currentSchema);
            console.log('Active sections:', [...activeSections]);
            
            // Test field creation contexts
            const normalContext = new FieldCreationContext('normal');
            const modalContext = new FieldCreationContext('modal');
            const inlineContext = new FieldCreationContext('inline');
            
            console.log('Normal context ID prefix:', normalContext.idPrefix);
            console.log('Modal context ID prefix:', modalContext.idPrefix);
            console.log('Inline context ID prefix:', inlineContext.idPrefix);
            
            // Test dependency system
            console.log('\n=== Dependency System Test ===');
            Object.entries(FIELD_DEPENDENCIES).forEach(([dependent, parent]) => {
                console.log(`${dependent} depends on ${parent}`);
                
                const dependentField = document.getElementById(dependent);
                const parentField = document.getElementById(parent);
                
                console.log(`  Dependent field exists: ${!!dependentField}`);
                console.log(`  Parent field exists: ${!!parentField}`);
            });
            
            // Test specific fixes
            console.log('\n=== Testing Specific Fixes ===');
            
            // Test 1: Currency field dependency
            console.log('1. Currency field dependency test:');
            const modalCurrencyDep = FIELD_DEPENDENCIES['currency'];
            console.log(`   Modal currency depends on: ${modalCurrencyDep}`);
            const normalCurrencyDep = FIELD_DEPENDENCIES['loss.impact_and_losses.currency'];
            console.log(`   Normal currency depends on: ${normalCurrencyDep}`);
            
            // Test 2: Hazard process dependencies 
            console.log('2. Hazard process dependency test:');
            const modalProcessDep = FIELD_DEPENDENCIES['processes'];
            console.log(`   Modal processes depends on: ${modalProcessDep}`);
            const lossProcessDep = FIELD_DEPENDENCIES['loss.hazard_process'];
            console.log(`   Loss hazard_process depends on: ${lossProcessDep}`);
            
            // Test 3: Array context handling
            console.log('3. Array context test:');
            console.log(`   Inline context type: ${inlineContext.type}`);
            console.log(`   Inline context container:`, !!inlineContext.container);
            
            // Test unified factory
            console.log('\n=== Field Factory Test ===');
            const testProperty = {
                type: 'string',
                enum: ['option1', 'option2', 'option3'],
                title: 'Test Field'
            };
            
            const factory = new UnifiedFieldFactory(normalContext);
            console.log('Factory created successfully');
            
            // Test validation system
            console.log('\n=== Validation System Test ===');
            const validator = new UnifiedFieldValidator(normalContext);
            const validationResult = validator.validate('test_field', 'test_value', testProperty);
            console.log('Validation result:', validationResult);
            
            console.log('\n=== System Integration Complete ===');
            console.log('All three fixes should now be working:');
            console.log('✓ Inline array editing in modals');
            console.log('✓ Currency field dependency in all contexts');
            console.log('✓ Hazard process dependency in all tabs');
        }

        // Additional helper function to test dependencies after form loads
        function testDependenciesAfterLoad() {
            setTimeout(() => {
                console.log('\n=== Post-Load Dependency Test ===');
                
                // Test hazard type -> process dependencies in all contexts
                const hazardTypeFields = [
                    'vulnerability.hazard_primary',
                    'loss.hazard_type',
                    'hazards.type'
                ];
                
                hazardTypeFields.forEach(fieldName => {
                    const field = document.getElementById(fieldName);
                    if (field) {
                        console.log(`Found hazard type field: ${fieldName}`);
                        
                        // Find its corresponding process field
                        let processFieldName;
                        if (fieldName.includes('vulnerability')) {
                            processFieldName = fieldName.replace('hazard_primary', 'hazard_process_primary');
                        } else if (fieldName.includes('loss')) {
                            processFieldName = fieldName.replace('hazard_type', 'hazard_process');
                        } else if (fieldName.includes('hazards')) {
                            processFieldName = fieldName.replace('type', 'processes');
                        }
                        
                        const processField = document.getElementById(processFieldName);
                        console.log(`  Corresponding process field ${processFieldName}: ${!!processField}`);
                        
                        if (processField) {
                            console.log(`  Process field has ${processField.options.length} options`);
                        }
                    }
                });
                
                // Test currency fields
                const currencyFields = [
                    'loss.impact_and_losses.currency',
                    'modal_currency'
                ];
                
                currencyFields.forEach(fieldName => {
                    const field = document.getElementById(fieldName);
                    if (field) {
                        const container = field.closest('.form-field, .modal-form-field');
                        console.log(`Found currency field: ${fieldName}, visible: ${container ? container.style.display !== 'none' : 'no container'}`);
                    }
                });
                
            }, 3000);
        }

        // Call test functions
        setTimeout(() => {
            if (typeof testUnifiedSystem === 'function') {
                testUnifiedSystem();
            }
            if (typeof testDependenciesAfterLoad === 'function') {
                testDependenciesAfterLoad();
            }
        }, 2000);

    </script>
</body>
</html>
