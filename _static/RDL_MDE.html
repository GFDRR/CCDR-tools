<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDLS Metadata Editor</title>
    <link rel="icon" href="https://riskdatalibrary.org/assets/images/favicon/favicon.png" type="image/png">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .section-checkbox {
            margin-bottom: 0.5rem;
        }
        .tab-content {
            min-height: 400px;
        }
        .nav-tabs .nav-link {
            border-radius: 0.5rem 0.5rem 0 0;
        }
        .nav-tabs .nav-link.hazard-tab {
            background-color: #e6f3ff;
            border-color: #007fc3;
            color: #007fc3;
        }
        .nav-tabs .nav-link.hazard-tab.active {
            background-color: #007fc3;
            border-color: #007fc3;
            color: white;
        }
        .nav-tabs .nav-link.exposure-tab {
            background-color: #e6fffe;
            border-color: #00cbab;
            color: #00cbab;
        }
        .nav-tabs .nav-link.exposure-tab.active {
            background-color: #00cbab;
            border-color: #00cbab;
            color: white;
        }
        .nav-tabs .nav-link.vulnerability-tab {
            background-color: #fff9e6;
            border-color: #ffc757;
            color: #b8941f;
        }
        .nav-tabs .nav-link.vulnerability-tab.active {
            background-color: #ffc757;
            border-color: #ffc757;
            color: white;
        }
        .nav-tabs .nav-link.loss-tab {
            background-color: #ffe6ec;
            border-color: #f3436a;
            color: #f3436a;
        }
        .nav-tabs .nav-link.loss-tab.active {
            background-color: #f3436a;
            border-color: #f3436a;
            color: white;
        }
        .nav-tabs .nav-link.general-tab {
            background-color: #f8f9fa;
            border-color: #6c757d;
            color: #6c757d;
        }
        .nav-tabs .nav-link.general-tab.active {
            background-color: #6c757d;
            border-color: #6c757d;
            color: white;
        }
        .form-field { 
            margin-bottom: 1rem; 
            position: relative;
        }
        .validation-indicator {
            position: absolute;
            right: 10px;
            top: 35px;
            z-index: 10;
            font-size: 1.2rem;
        }
        .validation-indicator.valid {
            color: #28a745;
        }
        .validation-indicator.invalid {
            color: #dc3545;
        }
        .field-with-validation {
            padding-right: 35px;
        }
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .autocomplete-suggestion {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
        }
        .autocomplete-suggestion:hover {
            background-color: #f8f9fa;
        }
        .combobox-wrapper {
            position: relative;
        }
        .combobox-wrapper .dropdown-toggle {
            border-left: none;
            padding: 0.375rem 0.5rem;
        }
        .combobox-wrapper .form-control {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        .combobox-wrapper .btn {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
        .array-field { 
            border: 1px solid #dee2e6; 
            padding: 1rem; 
            border-radius: 0.375rem; 
            margin-bottom: 1rem; 
            background-color: #fafafa;
        }
        .array-item { 
            background-color: #f8f9fa; 
            padding: 0.5rem; 
            margin: 0.5rem 0; 
            border-radius: 0.25rem; 
            border: 1px solid #e9ecef;
        }
        .object-field { 
            border: 1px solid #e9ecef; 
            padding: 1rem; 
            border-radius: 0.375rem; 
            margin-bottom: 1rem; 
            background-color: #fbfcfd; 
        }
        .required { 
            border-left: 3px solid #dc3545; 
            padding-left: 0.5rem;
        }
        .schema-status {
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }
        .file-drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            margin: 1rem 0;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }
        .file-drop-zone:hover { border-color: #007bff; }
        .file-drop-zone.dragover { border-color: #28a745; background-color: #f8f9fa; }
        .validation-progress {
            margin-bottom: 1rem;
        }
        .object-summary-card {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }
        .object-summary-title {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }
        .object-summary-details {
            font-size: 0.875rem;
            color: #6c757d;
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
        }
        .object-modal {
            max-width: 800px;
        }
        .modal-form-field {
            margin-bottom: 1rem;
        }
        .field-hint {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 0.25rem;
        }
        .bbox-field {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .bbox-field input {
            font-size: 0.9rem;
        }
        .bbox-preview {
            background-color: #f8f9fa !important;
            font-family: 'Courier New', monospace !important;
            color: #495057;
            border: 1px solid #ced4da;
        }

        /* Inline array editing styles */
        .array-field .card {
            border-left: 4px solid #0d6efd;
            margin-bottom: 0.75rem;
        }

        .array-field .card .card-body {
            background-color: #f8f9ff;
        }

        .array-field .modal-form-field {
            margin-bottom: 0.75rem;
        }

        .array-field .card:hover {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }

        /* Special styling for problematic nested arrays */
        .array-field[data-array-name*="disaster_identifiers"] .card {
            border-left-color: #dc3545;
        }

        .array-field[data-array-name*="disaster_identifiers"] .card .card-body {
            background-color: #fff5f5;
        }

    </style>
</head>
<body>
    <div class="container-fluid">
        <header class="py-4 border-bottom">
            <div class="d-flex align-items-center gap-3">
                <img src="https://gfdrr.github.io/CCDR-tools/_static/logo_flat.png" alt="GFDRR Logo" style="height: 100px;">
                <div>
                    <h1 class="h3 mb-1">RDLS Metadata Editor</h1>
                    <p class="text-muted mb-0">
                        Unified field creation system with guided dependencies and validation
                        <span class="badge bg-primary ms-2">Optimised for v0.3 and later</span>
                    </p>
                </div>
            </div>
        </header>

        <div class="row mt-4">
            <!-- Configuration Panel -->
            <div class="col-md-3">
                <!-- Schema Version Selection -->
                <div class="card mb-3">
                    <div class="card-header">
                        <h5>üìã Schema Configuration</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label">Schema Version:</label>
                            <select id="schemaVersionSelect" class="form-select">
                                <option value="">Loading schema versions...</option>
                            </select>
                            <div id="schemaStatus" class="schema-status text-muted"></div>
                        </div>

                        <!-- Section Selectors -->
                        <div class="mb-3">
                            <label class="form-label">Dataset Sections:</label>
                            <div class="section-checkbox">
                                <input type="checkbox" id="generalCheck" class="form-check-input" checked disabled>
                                <label for="generalCheck" class="form-check-label ms-2">
                                    <span class="badge bg-secondary">General Metadata</span> (Required)
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="hazardCheck" class="form-check-input">
                                <label for="hazardCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #007fc3;">Hazard Metadata</span>
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="exposureCheck" class="form-check-input">
                                <label for="exposureCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #00cbab;">Exposure Metadata</span>
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="vulnerabilityCheck" class="form-check-input">
                                <label for="vulnerabilityCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #ffc757">Vulnerability Metadata</span>
                                </label>
                            </div>
                            <div class="section-checkbox">
                                <input type="checkbox" id="lossCheck" class="form-check-input">
                                <label for="lossCheck" class="form-check-label ms-2">
                                    <span class="badge" style="background-color: #f3436a;">Loss Metadata</span>
                                </label>
                            </div>
                        </div>

                        <!-- Custom Schema Upload -->
                        <div class="mb-3">
                            <label class="form-label">Custom Schema:</label>
                            <div class="file-drop-zone" id="schemaDropZone">
                                <small>üìÅ Drop RDLS schema file here<br>or click to browse</small>
                                <input type="file" id="schemaFile" accept=".json" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Actions Panel -->
                <div class="card">
                    <div class="card-header">
                        <h6>üíæ Data Management</h6>
                    </div>
                        <div class="card-body">
                            <button id="loadData" class="btn btn-outline-secondary btn-sm w-100 mb-2">Load Existing Metadata</button>
                            <button id="saveProgress" class="btn btn-outline-info btn-sm w-100 mb-2">Save Progress</button>
                            <button id="resetForm" class="btn btn-outline-warning btn-sm w-100 mb-2">üîÑ Reset All Data</button>
                            <button id="validateForm" class="btn btn-outline-primary btn-sm w-100 mb-2">üîç Validate Metadata</button>
                            <button id="exportJson" class="btn btn-success btn-sm w-100 mb-2">Export JSON</button>
                            <button id="exportXml" class="btn btn-success btn-sm w-100 mb-2">Export XML</button>
                            <button id="publishGitHub" class="btn btn-warning btn-sm w-100 mb-2" disabled>üì§ Publish to GitHub</button>
                        </div>
                </div>
            </div>

            <!-- Form Generation Area -->
            <div class="col-md-6">
                <div class="card h-100">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5>üìã RDLS Metadata Form</h5>
                        <span id="formStatus" class="badge bg-secondary">No schema loaded</span>
                    </div>
                    <div class="card-body">
                        <!-- Tab Navigation -->
                        <ul class="nav nav-tabs" id="metadataTabs" role="tablist" style="display: none;">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active general-tab" id="general-tab" data-bs-toggle="tab" data-bs-target="#general" type="button" role="tab">
                                    General
                                </button>
                            </li>
                        </ul>

                        <!-- Tab Content -->
                        <div class="tab-content" id="metadataTabContent">
                            <div class="tab-pane fade show active" id="general" role="tabpanel">
                                <div id="metadataForm">
                                    <div class="text-center text-muted py-5">
                                        <div style="font-size: 4rem;">üåç</div>
                                        <p>Schema will load automatically and configure sections as needed</p>
                                        <small class="text-muted">Refactored with unified field creation and improved dependency handling - meant to work with RDLS v0.3 or later</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Output Preview -->
            <div class="col-md-3">
                <div class="card h-100">
                    <div class="card-header">
                        <h6>üëÄ Live Preview & Validation</h6>
                    </div>
                    <div class="card-body">
                        <!-- Validation Progress -->
                        <div class="validation-progress">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <small class="text-muted"><strong>Validation Status</strong></small>
                                <span id="overallValidation" class="badge bg-secondary">Not validated</span>
                            </div>
                            <div class="progress mb-2" style="height: 8px;">
                                <div id="validationProgress" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                            </div>
                            <small class="text-muted">
                                <span id="validFieldCount">0</span>/<span id="totalFieldCount">0</span> fields valid
                            </small>
                        </div>
                        
                        <pre id="outputPreview" class="bg-light p-3 rounded" style="font-size: 0.8rem; max-height: 600px; overflow-y: auto;">
{
  "message": "Refactored RDLS metadata will appear here..."
}
                        </pre>
                        
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Object Editor Modal -->
    <div class="modal fade" id="objectEditorModal" tabindex="-1" aria-labelledby="objectEditorModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg object-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="objectEditorModalLabel">Edit Object</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="objectEditorForm" class="needs-validation" novalidate>
                        <div id="objectEditorFields">
                            <!-- Dynamic form fields will be inserted here -->
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveObjectBtn">Save Object</button>
                </div>
            </div>
        </div>
    </div>

    <!-- GitHub Configuration Modal -->
    <div class="modal fade" id="githubConfigModal" tabindex="-1" aria-labelledby="githubConfigModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="githubConfigModalLabel">GitHub Configuration</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <strong>Setup Instructions:</strong>
                        <ol class="mb-0 mt-2">
                            <li>Create a <a href="https://github.com/settings/tokens" target="_blank">Personal Access Token</a> with <code>repo</code> permissions</li>
                            <li>Enter your token below (it will be stored securely in your session)</li>
                            <li>Confirm the target repository and branch settings</li>
                        </ol>
                    </div>

                    <form id="githubConfigForm">
                        <div class="mb-3">
                            <label for="githubToken" class="form-label">GitHub Personal Access Token <span class="text-danger">*</span></label>
                            <input type="password" class="form-control" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" required>
                            <div class="form-text">Your token is stored securely and only for this session</div>
                        </div>

                        <div class="mb-3">
                            <label for="githubRepo" class="form-label">Target Repository</label>
                            <input type="text" class="form-control" id="githubRepo" value="GFDRR/rdl-jkan" readonly>
                            <div class="form-text">Repository where the dataset will be published</div>
                        </div>

                        <div class="mb-3">
                            <label for="githubBranch" class="form-label">Target Branch</label>
                            <input type="text" class="form-control" id="githubBranch" value="rdl-0.3" readonly>
                            <div class="form-text">Base branch for the pull request</div>
                        </div>

                        <div class="mb-3">
                            <label for="datasetTitle" class="form-label">Dataset Title (for filename)</label>
                            <input type="text" class="form-control" id="datasetTitle" placeholder="Will be auto-filled from metadata">
                            <div class="form-text">Used to generate the filename: dataset-title-timestamp.json</div>
                        </div>

                        <div id="githubConfigStatus" class="mt-3"></div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-success" id="testGithubConnection">Test Connection</button>
                    <button type="button" class="btn btn-primary" id="publishToGithub">Publish Dataset</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Include Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>

    <script>
        // RDLS Schema Configuration
        const RDLS_VERSIONS = {
            '0.2': 'https://docs.riskdatalibrary.org/en/0__2__0/rdls_schema.json',
            '0.3': 'rdls_schema_v3.json'
        };

        const SECTIONS = ['hazard', 'exposure', 'vulnerability', 'loss'];

        // IMT mappings will be loaded from schema
        let HAZARD_IMT_MAPPING = null;
        let IMT_DEFINITIONS = {};

        // Legacy hardcoded mapping (will be replaced by schema-based mapping)
        const LEGACY_HAZARD_IMT_MAPPING = {
            'flood': [
                {code: 'flow_depth_ground:m', title: 'Flow depth above ground in meters'},
                {code: 'flow_depth_ground:cm', title: 'Flow depth above ground in centimeters'},
                {code: 'flow_depth_ground:dm', title: 'Flow depth above ground in decimeters'},
                {code: 'flow_depth_floor:m', title: 'Flow depth above floor level in meters'},
                {code: 'flow_depth_floor:cm', title: 'Flow depth above floor level in centimeters'},
                {code: 'flow_depth_floor:dm', title: 'Flow depth above floor level in decimeters'},
                {code: 'fv:m/s', title: 'Flow velocity (m/s)'},
                {code: 'fv:km/h', title: 'Flow velocity (km/h)'},
                {code: 'slr:cm', title: 'Sea Level Rise'},
                {code: 'pptn1:mm', title: '1-hour precipitation'},
                {code: 'pptn24:mm', title: '24-hour precipitation'},
                {code: 'pptn_tot:mm', title: 'Total event precipitation'}
            ],
            'tsunami': [
                {code: 'flow_depth_ground:m', title: 'Flow depth above ground in meters'},
                {code: 'flow_depth_ground:cm', title: 'Flow depth above ground in centimeters'},
                {code: 'flow_depth_ground:dm', title: 'Flow depth above ground in decimeters'},
                {code: 'flow_depth_floor:m', title: 'Flow depth above floor level in meters'},
                {code: 'flow_depth_floor:cm', title: 'Flow depth above floor level in centimeters'},
                {code: 'flow_depth_floor:dm', title: 'Flow depth above floor level in decimeters'},
                {code: 'fv:m/s', title: 'Flow velocity (m/s)'},
                {code: 'fv:km/h', title: 'Flow velocity (km/h)'},
                {code: 'Rh_tsi:m', title: 'Tsunami wave runup height'},
                {code: 'h_tsi:m', title: 'Tsunami inundation height'},
                {code: 'F_drag:kN', title: 'Hydrodynamic drag force'},
                {code: 'F_QS:kN', title: 'Quasi-static buoyant force'},
                {code: 'MF:m3/s2', title: 'Momentum flux'},
                {code: 'slr:cm', title: 'Sea Level Rise'}
            ],
            'coastal_flood': [
                {code: 'flow_depth_ground:m', title: 'Flow depth above ground in meters'},
                {code: 'flow_depth_ground:cm', title: 'Flow depth above ground in centimeters'},
                {code: 'flow_depth_ground:dm', title: 'Flow depth above ground in decimeters'},
                {code: 'flow_depth_floor:m', title: 'Flow depth above floor level in meters'},
                {code: 'flow_depth_floor:cm', title: 'Flow depth above floor level in centimeters'},
                {code: 'flow_depth_floor:dm', title: 'Flow depth above floor level in decimeters'},
                {code: 'fv:m/s', title: 'Flow velocity (m/s)'},
                {code: 'fv:km/h', title: 'Flow velocity (km/h)'},
                {code: 'slr:cm', title: 'Sea Level Rise'}
            ],
            'earthquake': [
                {code: 'PGA:g', title: 'Peak ground acceleration in g'},
                {code: 'PGA:gal', title: 'Peak ground acceleration in gal'},
                {code: 'PGA:m/s2', title: 'Peak ground acceleration in m/s^2'},
                {code: 'PGV:m/s', title: 'Peak ground velocity in m/s'},
                {code: 'PGV:cm/s', title: 'Peak ground velocity in cm/s'},
                {code: 'AvgSa:m/s2', title: 'Average spectral acceleration in m/s^2'},
                {code: 'Sa_1:m/s2', title: 'Spectral acceleration (period: 1 sec) in m/s^2'},
                {code: 'Sd(T1):m', title: 'Spectral displacement'},
                {code: 'Sv(T1):m/s', title: 'Spectral velocity'},
                {code: 'PGDf:m', title: 'Permanent ground deformation'},
                {code: 'D:s', title: 'Significant duration'},
                {code: 'D_B:s', title: 'Bracketed duration'},
                {code: 'IA:m/s', title: 'Arias intensity'},
                {code: 'CAV:m/s', title: 'Cumulative absolute velocity'},
                {code: 'MMI:-', title: 'Modified Mercalli Intensity'},
                {code: 'EMS:-', title: 'European macroseismic scale'}
            ],
            'strong_wind': [
                {code: 'sustained_wind_speed:m/s', title: 'Sustained wind speed in m/s'},
                {code: 'sustained_wind_speed:km/h', title: 'Sustained wind speed in km/h'},
                {code: 'sustained_wind_speed:mph', title: 'Sustained wind speed in mph'},
                {code: 'peak_wind_gust:m/s', title: 'Peak wind gust in m/s'},
                {code: 'peak_wind_gust:km/h', title: 'Peak wind gust in km/h'},
                {code: 'peak_wind_gust:mph', title: 'Peak wind gust in mph'}
            ],
            'convective_storm': [
                {code: 'sustained_wind_speed:m/s', title: 'Sustained wind speed in m/s'},
                {code: 'sustained_wind_speed:km/h', title: 'Sustained wind speed in km/h'},
                {code: 'sustained_wind_speed:mph', title: 'Sustained wind speed in mph'},
                {code: 'peak_wind_gust:m/s', title: 'Peak wind gust in m/s'},
                {code: 'peak_wind_gust:km/h', title: 'Peak wind gust in km/h'},
                {code: 'peak_wind_gust:mph', title: 'Peak wind gust in mph'},
                {code: 'ImpactE:J', title: 'Impact Energy (Joules)'},
                {code: 'EF:-', title: 'Enhanced Fujita Scale'},
                {code: 'TPL:m', title: 'Tornado Path Length'},
                {code: 'TPW:m', title: 'Tornado Path Width'},
                {code: 'HSI:-', title: 'Hail Size Index'},
                {code: 'HlMaxSz:mm', title: 'Maximum hail size'},
                {code: 'HlProb:%', title: 'Hail probability'},
                {code: 'HlD:mm', title: 'Hail depth'}
            ],
            'drought': [
                {code: 'SPI:-', title: 'Standard Precipitation Index'},
                {code: 'SPEI:-', title: 'Standard Precipitation Evapotranspiration Index'},
                {code: 'PDSI:-', title: 'Palmer Drought Severity Index'},
                {code: 'CMI:-', title: 'Crop Moisture Index'},
                {code: 'NDVI:-', title: 'Normalized Difference Vegetation Index'},
                {code: 'VCI:-', title: 'Vegetation Condition Index'}
            ],
            'extreme_temperature': [
                {code: 'AirTemp:C', title: 'Air Temperature (¬∞C)'},
                {code: 'AirTemp:F', title: 'Air Temperature (¬∞F)'},
                {code: 'WBGT:C', title: 'Wet Bulb Globe Temperature in Celsius'},
                {code: 'HI:-', title: 'Heat Index'},
                {code: 'EHF:-', title: 'Excess Heat Factor'},
                {code: 'CDD:-', title: 'Cooling Degree Days'}
            ],
            'landslide': [
                {code: 'flow_depth_ground:m', title: 'Flow depth above ground in meters'},
                {code: 'flow_depth_ground:cm', title: 'Flow depth above ground in centimeters'},
                {code: 'flow_depth_ground:dm', title: 'Flow depth above ground in decimeters'},
                {code: 'fv:m/s', title: 'Flow velocity (m/s)'},
                {code: 'fv:km/h', title: 'Flow velocity (km/h)'},
                {code: 'ls_mfd:m', title: 'Maximum foundation displacement'},
                {code: 'SD_lsl:m', title: 'Surface displacement from landslide'},
                {code: 'I_DF:m3/s2', title: 'Debris flow intensity'},
                {code: 'rf_KE:kJ', title: 'Rockfall kinetic energy'},
                {code: 'LSI:-', title: 'Landslide Susceptibility Index'},
                {code: 'DP:-', title: 'Destructive Potential'},
                {code: 'AvSize:-', title: 'Avalanche Size'},
                {code: 'Rdist:m', title: 'Runout Distance'},
                {code: 'Vol:m3', title: 'Volume'}
            ],
            'volcanic': [
                {code: 'flow_depth_ground:m', title: 'Flow depth above ground in meters'},
                {code: 'flow_depth_ground:cm', title: 'Flow depth above ground in centimeters'},
                {code: 'flow_depth_ground:dm', title: 'Flow depth above ground in decimeters'},
                {code: 'fv:m/s', title: 'Flow velocity (m/s)'},
                {code: 'fv:km/h', title: 'Flow velocity (km/h)'},
                {code: 'Rdist:m', title: 'Runout Distance'},
                {code: 'h_vaf:mm', title: 'Volcanic ash fall thickness'},
                {code: 'vei:-', title: 'Volcanic Explosivity Index'},
                {code: 'ImpactE:kJ', title: 'Impact Energy'},
                {code: 'Vbal_size:m', title: 'Volcanic ballistic size'},
                {code: 'Vbal_Lprob:%', title: 'Volcanic ballistic landing probability'},
                {code: 'ImpactE:J', title: 'Impact Energy (Joules)'}
            ],
            'wildfire': [
                {code: 'burned_area:ha', title: 'Burned area in hectares'},
                {code: 'burned_area:km2', title: 'Burned area in square kilometers'},
                {code: 'FWI:-', title: 'Fire Weather Index'}
            ]
        };

        // Universal IMT options that apply to multiple hazards
        let UNIVERSAL_IMTS = [
            {code: 'affected_area:m2', title: 'Affected area in square meters'},
            {code: 'affected_area:km2', title: 'Affected area in square kilometers'},
            {code: 'affected_area:ha', title: 'Affected area in hectares'},
            {code: 'riskidx:-', title: 'Risk Index'},
            {code: 'MHI:-', title: 'Multi-hazard Index'}
        ];

        // Function to get filtered IMT options based on hazard type
        function getFilteredIMTOptions(selectedHazardType) {
            // Use legacy mapping if schema-based mapping not loaded yet
            const mapping = HAZARD_IMT_MAPPING || LEGACY_HAZARD_IMT_MAPPING;

            if (!selectedHazardType || !mapping || !mapping[selectedHazardType]) {
                // Return all IMT options if no hazard selected or unknown hazard
                const allIMTs = [];
                if (mapping) {
                    Object.values(mapping).forEach(imts => allIMTs.push(...imts));
                }
                allIMTs.push(...UNIVERSAL_IMTS);

                // Remove duplicates
                const uniqueIMTs = allIMTs.filter((imt, index, self) =>
                    index === self.findIndex(i => i.code === imt.code)
                );
                return uniqueIMTs;
            }

            // Return hazard-specific IMTs plus universal ones
            const hazardIMTs = [...mapping[selectedHazardType]];
            hazardIMTs.push(...UNIVERSAL_IMTS);
            return hazardIMTs;
        }

        // Function to update IMT dropdowns when hazard changes
        function updateIMTOptionsForHazard(hazardType) {
            const filteredOptions = getFilteredIMTOptions(hazardType);

            // Find all intensity_measure fields and update them
            // This includes both select elements and combobox inputs
            document.querySelectorAll('select[id*="intensity_measure"], input[id*="intensity_measure"]').forEach(element => {
                if (element.tagName === 'SELECT') {
                    // Handle select dropdowns
                    const currentValue = element.value;

                    // Clear existing options except the first empty option
                    const firstOption = element.firstElementChild;
                    element.innerHTML = '';
                    if (firstOption && firstOption.value === '') {
                        element.appendChild(firstOption);
                    } else {
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = 'Select intensity measure...';
                        element.appendChild(emptyOption);
                    }

                    // Add filtered options
                    filteredOptions.forEach(option => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option.code;
                        // Display only title (unit is already included in title)
                        optionElement.textContent = option.title;
                        if (option.description) {
                            optionElement.setAttribute('title', option.description);
                        }
                        element.appendChild(optionElement);
                    });

                    // Restore previous value if still valid
                    if (filteredOptions.some(opt => opt.code === currentValue)) {
                        element.value = currentValue;
                    } else {
                        element.value = '';
                        // Update form data to reflect cleared value
                        const fieldPath = element.getAttribute('data-field');
                        if (fieldPath) {
                            setNestedValue(currentFormData, fieldPath, '');
                            autoSave();
                        }
                    }
                } else if (element.tagName === 'INPUT') {
                    // Handle combobox inputs - update their dropdown menu
                    const wrapper = element.closest('.combobox-wrapper');
                    if (wrapper) {
                        const dropdownMenu = wrapper.querySelector('.dropdown-menu');
                        if (dropdownMenu) {
                            // Clear existing options
                            dropdownMenu.innerHTML = '';

                            // Add filtered options
                            filteredOptions.forEach(option => {
                                const item = document.createElement('li');
                                const link = document.createElement('a');
                                link.className = 'dropdown-item';
                                link.href = '#';
                                // Display only title (unit is already included in title)
                                link.textContent = option.title;
                                if (option.description) {
                                    link.setAttribute('title', option.description);
                                }
                                link.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    element.value = option.code;
                                    updateFormData();
                                    // Validate the field
                                    const fieldName = element.id.replace(/^modal_/, '');
                                    const property = {}; // We'd need to get this from schema, but basic validation should work
                                    // TODO: Add validation here if needed
                                });
                                item.appendChild(link);
                                dropdownMenu.appendChild(item);
                            });

                            // Add separator and custom value option
                            if (filteredOptions.length > 0) {
                                const separator = document.createElement('li');
                                separator.innerHTML = '<hr class="dropdown-divider">';
                                dropdownMenu.appendChild(separator);

                                const customItem = document.createElement('li');
                                customItem.innerHTML = '<span class="dropdown-item-text text-muted"><em>üí° You can also type a custom value</em></span>';
                                dropdownMenu.appendChild(customItem);
                            }
                        }
                    }

                    // Check if current value is still valid
                    const currentValue = element.value;
                    if (currentValue && !filteredOptions.some(opt => opt.code === currentValue)) {
                        // Current value is no longer valid for this hazard type
                        element.value = '';
                        updateFormData();
                    }
                }
            });
        }

        let currentSchema = null;
        let currentFormData = {};
        let activeSections = new Set(['general']);
        let fieldValidationStatus = new Map();

        // Object editor state
        let currentObjectEditor = {
            arrayName: null,
            objectIndex: null,
            objectSchema: null,
            arrayData: null,
            renderCallback: null
        };

        // Country names cache
        let countryNames = {};

        // Dependency configuration - centralized
        const FIELD_DEPENDENCIES = {
            'vulnerability.hazard_process_primary': 'vulnerability.hazard_primary',
            'vulnerability.hazard_process_secondary': 'vulnerability.hazard_secondary',
            'loss.hazard_process': 'loss.hazard_type',
            'loss.impact_and_losses.currency': 'loss.impact_and_losses.impact_unit',
            'loss.losses.impact_and_losses.currency': 'loss.losses.impact_and_losses.impact_unit',
            'hazards.processes': 'hazards.type',
            'hazards.intensity_measure': 'hazards.type',
            'vulnerability.intensity_measure': 'vulnerability.hazard_primary',
            // Modal context dependencies
            'processes': 'type',
            'hazard_process': 'hazard_type',
            'hazard_process_primary': 'hazard_primary',
            'hazard_process_secondary': 'hazard_secondary',
            'intensity_measure': 'type', // For hazard context, could also be 'hazard_primary' for vulnerability context
            'currency': 'quantity_kind',
            // Section-specific currency dependencies
            'exposure.currency': 'exposure.quantity_kind',
            'vulnerability.currency': 'vulnerability.quantity_kind',
            'loss.currency': 'loss.quantity_kind',
            // Impact and losses specific dependencies (for loss modals)
            'impact_and_losses.currency': 'impact_and_losses.quantity_kind'
        };

        // Auto-completion suggestions for common fields
        const AUTO_COMPLETE_SUGGESTIONS = {
            'title': [
                'Global Flood Risk Assessment',
                'Earthquake Hazard Database',
                'Climate Change Vulnerability Index',
                'Urban Exposure Inventory',
                'Disaster Loss Database'
            ],
            'purpose': [
                'Risk assessment for urban planning',
                'Insurance portfolio analysis',
                'Climate adaptation planning',
                'Disaster risk reduction strategy development'
            ]
        };

        // ================================
        // UNIFIED FIELD CREATION SYSTEM
        // ================================
        
        /**
         * Unified Field Creation Context
         * Handles all field creation needs across normal, modal, and array contexts
         */
        class FieldCreationContext {
            constructor(type = 'normal', container = null) {
                this.type = type; // 'normal', 'modal', 'inline', 'array'
                this.container = container;
                this.idPrefix = type === 'modal' ? 'modal_' : '';
            }

            createField(name, property, value, options = {}) {
                const factory = new UnifiedFieldFactory(this);
                return factory.createField(name, property, value, options);
            }

            getFieldId(name) {
                return this.idPrefix + name;
            }

            setupEventListeners(element, name, property, options = {}) {
                const handler = new UnifiedEventHandler(this);
                handler.setupListeners(element, name, property, options);
            }

            validateField(name, value, property) {
                const validator = new UnifiedFieldValidator(this);
                return validator.validate(name, value, property);
            }
        }

        /**
         * Unified Field Factory
         * Creates appropriate field elements based on property type and context
         */
        class UnifiedFieldFactory {
            constructor(context) {
                this.context = context;
            }

            createField(name, property, value, options = {}) {
                // Skip ID fields in certain contexts
                if (name === 'id' || (name.includes('.id') && this.context.type === 'array')) {
                    return document.createElement('div');
                }

                // Skip trigger fields in hazard modal context - they're not needed for basic hazard entry
                if (this.context.type === 'modal' && name.includes('trigger')) {
                    return document.createElement('div');
                }

                const container = this.createFieldContainer(name, property, options);
                
                // Resolve $ref if present
                const resolvedProperty = this.resolveProperty(property);
                if (!resolvedProperty || !resolvedProperty.type) {
                    return container;
                }

                // Create label and description if not an object property
                const forceLabel = false;
                const isObjectProperty = resolvedProperty.type === 'object' && this.context.type !== 'modal' && this.context.type !== 'inline' && !name.includes('trigger') && !forceLabel;
                if (!isObjectProperty) {
                    this.addLabelAndDescription(container, name, resolvedProperty, options);
                }

                // Create the input element
                const inputElement = this.createInputElement(name, resolvedProperty, value, options);
                
                // Add validation indicator
                if (this.context.type === 'normal') {
                    this.addValidationIndicator(container, name);
                }

                container.appendChild(inputElement);

                // Add help text for intensity_measure fields (for select dropdowns)
                if (name.includes('intensity_measure') && inputElement.tagName === 'SELECT') {
                    const helpText = document.createElement('small');
                    helpText.className = 'form-text text-muted';
                    helpText.style.display = 'block';
                    helpText.style.marginTop = '0.25rem';
                    helpText.innerHTML = 'An intensity measure is missing? Please <a href="https://github.com/GFDRR/rdl-standard/issues/new?template=change-proposal.md" target="_blank" rel="noopener noreferrer">submit a request</a> to add a new one.';
                    container.appendChild(helpText);
                }

                // Add examples if available
                this.addExamples(container, resolvedProperty);

                // Handle dependencies
                this.handleDependencies(container, name, resolvedProperty, value);

                return container;
            }

            createFieldContainer(name, property, options) {
                const container = document.createElement('div');
                container.className = (this.context.type === 'modal' || this.context.type === 'inline') ? 'modal-form-field' : 'form-field';

                // Handle required fields
                if (this.isRequiredField(name, property, options)) {
                    container.classList.add('required');
                }

                return container;
            }

            resolveProperty(property) {
                if (property.$ref) {
                    const resolved = resolveReference(property.$ref);
                    if (resolved) {
                        return { ...resolved, title: property.title || resolved.title, description: property.description || resolved.description };
                    }
                }
                return property;
            }

            addLabelAndDescription(container, name, property, options) {
                const label = document.createElement('label');
                label.textContent = property.title || name.split('.').pop();
                label.className = 'form-label';
                label.htmlFor = this.context.getFieldId(name);
                
                if (this.isRequiredField(name, property, options)) {
                    label.innerHTML += ' <span class="text-danger">*</span>';
                }
                
                container.appendChild(label);
                
                if (property.description) {
                    const description = document.createElement('small');
                    description.className = 'form-text text-muted d-block mb-2';
                    description.innerHTML = parseMarkdownLinks(property.description);
                    container.appendChild(description);
                }
            }

            createInputElement(name, property, value, options) {
                switch (property.type) {
                    case 'string':
                        return this.createStringInput(name, property, value, options);
                    case 'integer':
                    case 'number':
                        return this.createNumberInput(name, property, value, options);
                    case 'boolean':
                        return this.createBooleanInput(name, property, value, options);
                    case 'array':
                        return this.createArrayInput(name, property, value, options);
                    case 'object':
                        return this.createObjectInput(name, property, value, options);
                    default:
                        return this.createStringInput(name, property, value, options);
                }
            }

            createStringInput(name, property, value, options) {
                // Special handling for currency fields - ensure they have enum options
                if (name.includes('currency') || name === 'currency') {
                    if (!property.enum) {
                        property = {...property, enum: ['USD', 'EUR', 'GBP', 'JPY', 'CHF', 'CAD', 'AUD']};
                    }
                }

                // Check for dependencies
                const dependsOn = FIELD_DEPENDENCIES[name];
                if (dependsOn) {
                    const parentValue = getNestedValue(currentFormData, dependsOn);
                    return this.createDependentSelect(name, property, value, dependsOn, parentValue, options);
                }

                if (property.enum) {
                    return this.createSelect(name, property, value, options);
                } else if (property.suggestions && property.openCodelist) {
                    return this.createCombobox(name, property, value, options);
                } else if (property.format === 'date') {
                    return this.createDateInput(name, property, value, options);
                } else if (property.format === 'email') {
                    return this.createEmailInput(name, property, value, options);
                } else if (property.format === 'iri') {
                    return this.createUrlInput(name, property, value, options);
                } else if (name.includes('description') || name.includes('purpose') || name.includes('notes') || name.includes('details')) {
                    return this.createTextareaInput(name, property, value, options);
                } else {
                    return this.createTextInput(name, property, value, options);
                }
            }

            createTextInput(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                if (property.minLength) input.minLength = property.minLength;
                if (property.maxLength) input.maxLength = property.maxLength;
                if (property.pattern) input.pattern = property.pattern;
                
                this.context.setupEventListeners(input, name, property, options);
                wrapper.appendChild(input);
                
                // Setup autocomplete if not in modal or inline
                if (this.context.type !== 'modal' && this.context.type !== 'inline') {
                    this.setupAutoComplete(input, name, property);
                }
                
                return wrapper;
            }

            createTextareaInput(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';

                const textarea = document.createElement('textarea');
                textarea.className = 'form-control field-with-validation';
                textarea.name = this.context.getFieldId(name);
                textarea.id = this.context.getFieldId(name);
                textarea.value = value || '';
                textarea.rows = 3;
                textarea.style.resize = 'vertical';
                textarea.style.minHeight = '80px';

                if (property.minLength) textarea.minLength = property.minLength;
                if (property.maxLength) textarea.maxLength = property.maxLength;

                // Auto-resize functionality
                const autoResize = () => {
                    textarea.style.height = 'auto';
                    textarea.style.height = Math.max(80, textarea.scrollHeight) + 'px';
                };

                textarea.addEventListener('input', autoResize);
                textarea.addEventListener('focus', autoResize);

                // Initial resize
                setTimeout(autoResize, 0);

                this.context.setupEventListeners(textarea, name, property, options);
                wrapper.appendChild(textarea);

                return wrapper;
            }

            createEmailInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = 'email';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createUrlInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = 'url';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createDateInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = 'date';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createNumberInput(name, property, value, options) {
                const input = document.createElement('input');
                input.type = property.type === 'integer' ? 'number' : 'number';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                
                if (property.minimum !== undefined) input.min = property.minimum;
                if (property.maximum !== undefined) input.max = property.maximum;
                if (property.type === 'integer') input.step = '1';
                
                this.context.setupEventListeners(input, name, property, options);
                return input;
            }

            createBooleanInput(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.className = 'form-check';
                
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-check-input';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.checked = value || false;
                
                const label = document.createElement('label');
                label.className = 'form-check-label';
                label.htmlFor = this.context.getFieldId(name);
                label.textContent = property.title || name;
                
                this.context.setupEventListeners(input, name, property, options);
                
                wrapper.appendChild(input);
                wrapper.appendChild(label);
                return wrapper;
            }

            createSelect(name, property, value, options) {
                const select = document.createElement('select');
                select.className = 'form-select field-with-validation';
                select.name = this.context.getFieldId(name);
                select.id = this.context.getFieldId(name);
                
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select an option...';
                select.appendChild(emptyOption);
                
                // Handle country dropdowns
                if (name.includes('countries') || (property.items && property.items.enum && property.items.enum.includes('USA'))) {
                    property.enum.forEach((option) => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        const countryName = countryNames[option] || option;
                        optionElement.textContent = `${option} - ${countryName}`;
                        if (value === option) optionElement.selected = true;
                        select.appendChild(optionElement);
                    });
                } else {
                    property.enum.forEach((option, index) => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        // Use enumNames if available, otherwise check if option contains parentheses (e.g., "CSV (csv)")
                        // If it has parentheses, use as-is; otherwise apply capitalization transformation
                        if (property.enumNames) {
                            optionElement.textContent = property.enumNames[index];
                        } else if (option.includes('(') && option.includes(')')) {
                            optionElement.textContent = option;
                        } else {
                            optionElement.textContent = option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        }
                        if (value === option) optionElement.selected = true;
                        select.appendChild(optionElement);
                    });
                }

                // Handle disabled option
                if (options.disabled) {
                    select.disabled = true;
                }

                this.context.setupEventListeners(select, name, property, options);
                return select;
            }

            createDependentSelect(name, property, value, dependsOn, parentValue, options) {
                const select = document.createElement('select');
                select.className = 'form-select field-with-validation';
                select.name = this.context.getFieldId(name);
                select.id = this.context.getFieldId(name);
                select.setAttribute('data-depends-on', dependsOn);
                
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select an option...';
                select.appendChild(emptyOption);
                
                // Start with all available options
                let availableOptions = property.enum || [];
                
                // Filter options if we have a parent value
                if (parentValue && currentSchema.hazard_process_mappings && name.includes('process')) {
                    availableOptions = currentSchema.hazard_process_mappings[parentValue] || property.enum || [];
                }
                
                // Populate options
                availableOptions.forEach((option, index) => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    // Use enumNames if available, otherwise check if option contains parentheses
                    if (property.enumNames) {
                        optionElement.textContent = property.enumNames[index];
                    } else if (option.includes('(') && option.includes(')')) {
                        optionElement.textContent = option;
                    } else {
                        optionElement.textContent = option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }
                    if (value === option) optionElement.selected = true;
                    select.appendChild(optionElement);
                });
                
                this.context.setupEventListeners(select, name, property, options);
                return select;
            }

            createCombobox(name, property, value, options) {
                const wrapper = document.createElement('div');
                wrapper.style.position = 'relative';
                wrapper.className = 'combobox-wrapper';
                
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control field-with-validation';
                input.name = this.context.getFieldId(name);
                input.id = this.context.getFieldId(name);
                input.value = value || '';
                input.placeholder = 'Type or select from suggestions...';
                
                if (property.minLength) input.minLength = property.minLength;
                if (property.maxLength) input.maxLength = property.maxLength;
                if (property.pattern) input.pattern = property.pattern;
                
                const dropdownBtn = document.createElement('button');
                dropdownBtn.type = 'button';
                dropdownBtn.className = 'btn btn-outline-secondary dropdown-toggle';
                dropdownBtn.setAttribute('data-bs-toggle', 'dropdown');
                
                const dropdownMenu = document.createElement('ul');
                dropdownMenu.className = 'dropdown-menu';
                dropdownMenu.style.maxHeight = '200px';
                dropdownMenu.style.overflowY = 'auto';
                
                // Get suggestions - use filtered IMT options for intensity_measure fields
                let suggestions = property.suggestions || [];
                if (name.includes('intensity_measure')) {
                    // Get current hazard type to filter IMT options
                    let hazardType = null;

                    if (this.context.type === 'normal') {
                        // Check different contexts for hazard type
                        hazardType = getNestedValue(currentFormData, 'hazards.type') ||
                                   getNestedValue(currentFormData, 'vulnerability.hazard_primary');
                    } else if (this.context.type === 'modal') {
                        // For modal context, try to find the hazard type field in the modal
                        let modalTypeField = document.getElementById('modal_type') ||
                                           document.getElementById('modal_hazard_primary');
                        if (modalTypeField) {
                            hazardType = modalTypeField.value;
                        }
                        if (!hazardType) {
                            hazardType = getNestedValue(currentFormData, 'type') ||
                                       getNestedValue(currentFormData, 'hazard_primary') ||
                                       getNestedValue(currentFormData, 'vulnerability.hazard_primary');
                        }
                    }

                    if (hazardType) {
                        const filteredIMTs = getFilteredIMTOptions(hazardType);
                        suggestions = filteredIMTs; // Keep full objects with code and title
                        console.log(`Creating ${name} combobox with ${suggestions.length} filtered options for hazard type: ${hazardType}`);
                    } else {
                        console.log(`No hazard type found for ${name} field, showing all IMT options`);
                    }
                }

                if (suggestions && suggestions.length > 0) {
                    suggestions.forEach(suggestion => {
                        const item = document.createElement('li');
                        const link = document.createElement('a');
                        link.className = 'dropdown-item';
                        link.href = '#';
                        // For IMT fields, display title; for other fields, display the string value
                        link.textContent = typeof suggestion === 'object' ? suggestion.title : suggestion;
                        if (typeof suggestion === 'object' && suggestion.description) {
                            link.setAttribute('title', suggestion.description);
                        }
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            // For IMT fields, use code; for other fields, use the string value
                            const valueToSet = typeof suggestion === 'object' ? suggestion.code : suggestion;
                            input.value = valueToSet;
                            updateFormData();
                            this.context.validateField(name, valueToSet, property);

                            // CRITICAL FIX: Trigger dependency handling when suggestion is clicked
                            const handler = new UnifiedEventHandler(this.context);
                            handler.handleDependentFields(name, valueToSet, input);
                        });
                        item.appendChild(link);
                        dropdownMenu.appendChild(item);
                    });
                    
                    const separator = document.createElement('li');
                    separator.innerHTML = '<hr class="dropdown-divider">';
                    dropdownMenu.appendChild(separator);
                    
                    const customItem = document.createElement('li');
                    customItem.innerHTML = '<span class="dropdown-item-text text-muted"><em>üí° You can also type a custom value</em></span>';
                    dropdownMenu.appendChild(customItem);
                }
                
                inputGroup.appendChild(input);
                inputGroup.appendChild(dropdownBtn);
                inputGroup.appendChild(dropdownMenu);
                
                this.context.setupEventListeners(input, name, property, options);
                wrapper.appendChild(inputGroup);

                // Add help text for intensity_measure fields
                if (name.includes('intensity_measure')) {
                    const helpText = document.createElement('small');
                    helpText.className = 'form-text text-muted';
                    helpText.style.display = 'block';
                    helpText.style.marginTop = '0.25rem';
                    helpText.innerHTML = 'An intensity measure is missing? Please <a href="https://github.com/GFDRR/rdl-standard/issues/new?template=proposal" target="_blank" rel="noopener noreferrer">submit a request</a> to add a new one.';
                    wrapper.appendChild(helpText);
                }

                if (this.context.type !== 'modal' && this.context.type !== 'inline') {
                    this.setupAutoComplete(input, name, property);
                }

                return wrapper;
            }

            createArrayInput(name, property, value, options) {
                if (name.includes('bbox')) {
                    return this.createBboxInput(name, property, value, options);
                } else if (name.includes('centroid')) {
                    return this.createCentroidInput(name, property, value, options);
                } else {
                    return this.createGenericArrayInput(name, property, value, options);
                }
            }

            createBboxInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'bbox-field border p-3 rounded bg-light';
                
                const title = document.createElement('h6');
                title.textContent = 'Bounding Box Coordinates (SW Longitude, SW Latitude, NE Longitude, NE Latitude)';
                title.className = 'mb-3';
                container.appendChild(title);
                
                const bboxData = value || [0, 0, 0, 0];
                const labels = ['SW Longitude', 'SW Latitude', 'NE Longitude', 'NE Latitude'];
                
                const inputsContainer = document.createElement('div');
                inputsContainer.className = 'row g-2';
                
                function updateBboxPreview() {
                    const currentBbox = getNestedValue(currentFormData, name) || [0, 0, 0, 0];
                    const previewInput = container.querySelector('.bbox-preview');
                    if (previewInput) {
                        previewInput.value = `[${currentBbox.join(', ')}]`;
                    }
                }
                
                for (let i = 0; i < 4; i++) {
                    const col = document.createElement('div');
                    col.className = 'col-md-6';
                    
                    const label = document.createElement('label');
                    label.textContent = labels[i];
                    label.className = 'form-label';
                    
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = 'any';
                    input.className = 'form-control';
                    input.name = `${this.context.getFieldId(name)}_${i}`;
                    input.value = bboxData[i] || 0;
                    input.placeholder = i % 2 === 0 ? 'Longitude' : 'Latitude';
                    
                    input.addEventListener('input', function() {
                        const currentBbox = getNestedValue(currentFormData, name) || [0, 0, 0, 0];
                        currentBbox[i] = parseFloat(this.value) || 0;
                        setNestedValue(currentFormData, name, currentBbox);
                        updateFormData();
                        updateBboxPreview();
                    });
                    
                    col.appendChild(label);
                    col.appendChild(input);
                    inputsContainer.appendChild(col);
                }
                
                container.appendChild(inputsContainer);
                
                const previewContainer = document.createElement('div');
                previewContainer.className = 'mt-3';
                
                const previewLabel = document.createElement('label');
                previewLabel.textContent = 'Bounding Box Array Format:';
                previewLabel.className = 'form-label';
                
                const previewInput = document.createElement('input');
                previewInput.type = 'text';
                previewInput.className = 'form-control bbox-preview';
                previewInput.readOnly = true;
                previewInput.value = `[${bboxData.join(', ')}]`;
                previewInput.style.backgroundColor = '#f8f9fa';
                previewInput.style.fontFamily = 'monospace';
                
                previewContainer.appendChild(previewLabel);
                previewContainer.appendChild(previewInput);
                container.appendChild(previewContainer);
                
                return container;
            }

            createCentroidInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'bbox-field border p-3 rounded bg-light';

                const title = document.createElement('h6');
                title.textContent = 'Centroid Coordinates (Longitude, Latitude)';
                title.className = 'mb-3';
                container.appendChild(title);

                const centroidData = value || [0, 0];
                const labels = ['Longitude', 'Latitude'];

                const inputsContainer = document.createElement('div');
                inputsContainer.className = 'row g-2';

                function updateCentroidPreview() {
                    const currentCentroid = getNestedValue(currentFormData, name) || [0, 0];
                    const previewInput = container.querySelector('.centroid-preview');
                    if (previewInput) {
                        previewInput.value = `Centroid point [${currentCentroid.join(', ')}]`;
                    }
                }

                for (let i = 0; i < 2; i++) {
                    const col = document.createElement('div');
                    col.className = 'col-md-6';

                    const label = document.createElement('label');
                    label.textContent = labels[i];
                    label.className = 'form-label';

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = 'any';
                    input.className = 'form-control';
                    input.name = `${this.context.getFieldId(name)}_${i}`;
                    input.value = centroidData[i] || 0;
                    input.placeholder = labels[i];

                    input.addEventListener('input', function() {
                        const currentCentroid = getNestedValue(currentFormData, name) || [0, 0];
                        currentCentroid[i] = parseFloat(this.value) || 0;
                        setNestedValue(currentFormData, name, currentCentroid);
                        updateFormData();
                        updateCentroidPreview();
                    });

                    col.appendChild(label);
                    col.appendChild(input);
                    inputsContainer.appendChild(col);
                }

                container.appendChild(inputsContainer);

                const previewContainer = document.createElement('div');
                previewContainer.className = 'mt-3';

                const previewLabel = document.createElement('label');
                previewLabel.textContent = 'Centroid Display:';
                previewLabel.className = 'form-label';

                const previewInput = document.createElement('input');
                previewInput.type = 'text';
                previewInput.className = 'form-control centroid-preview';
                previewInput.readOnly = true;
                previewInput.value = `Centroid point [${centroidData.join(', ')}]`;
                previewInput.style.backgroundColor = '#f8f9fa';
                previewInput.style.fontFamily = 'monospace';

                previewContainer.appendChild(previewLabel);
                previewContainer.appendChild(previewInput);
                container.appendChild(previewContainer);

                return container;
            }

            createGenericArrayInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'array-field';
                container.setAttribute('data-array-name', name);
                
                // Ensure arrayData is always an array and maintains reference to original data
                let arrayData;
                if (Array.isArray(value)) {
                    arrayData = value;
                } else {
                    arrayData = [];
                    // Initialize the array in currentFormData for normal context
                    if (this.context.type === 'normal') {
                        setNestedValue(currentFormData, name, arrayData);
                    } else if (this.context.type === 'modal') {
                        // Set the empty array in the source data so it gets properly saved
                        if (name && typeof name === 'string') {
                            // This will be handled by the modal save function
                        }
                    }
                }
                
                const itemsContainer = document.createElement('div');
                itemsContainer.id = `${this.context.getFieldId(name)}_items`;
                
                const renderArrayItems = () => {
                    itemsContainer.innerHTML = '';
                    
                    if (property.items && (property.items.$ref || property.items.type === 'object')) {
                        // Check if this is a problematic nested array that should be inline
                        const isProblematicArray = name.endsWith('.disaster_identifiers') ||
                                                 name === 'disaster_identifiers';

                        // For problematic arrays or modal context, create inline editing instead of opening new modals
                        if (this.context.type === 'modal' || isProblematicArray) {
                            arrayData.forEach((item, index) => {
                                const itemCard = this.createInlineObjectEditor(item, index, name, property, arrayData, renderArrayItems);
                                itemsContainer.appendChild(itemCard);
                            });
                        } else {
                            arrayData.forEach((item, index) => {
                                const objectCard = createObjectSummaryCard(item, index, name, property);
                                itemsContainer.appendChild(objectCard);
                            });
                        }
                    } else {
                        arrayData.forEach((item, index) => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'array-item d-flex gap-2 align-items-center mb-2';
                            
                            let input;
                            let itemSchema = property.items;
                            if (!itemSchema && property.$ref) {
                                itemSchema = resolveReference(property.$ref);
                            }
                            
                            if (itemSchema && itemSchema.type === 'string') {
                                if (itemSchema.enum) {
                                    input = document.createElement('select');
                                    input.className = 'form-select';
                                    
                                    const emptyOption = document.createElement('option');
                                    emptyOption.value = '';
                                    emptyOption.textContent = 'Select...';
                                    input.appendChild(emptyOption);
                                    
                                    if (itemSchema.enum.includes('USA') || itemSchema.enum.includes('GBR')) {
                                        itemSchema.enum.forEach((option) => {
                                            const optionElement = document.createElement('option');
                                            optionElement.value = option;
                                            const countryName = countryNames[option] || option;
                                            optionElement.textContent = `${option} - ${countryName}`;
                                            if (item === option) optionElement.selected = true;
                                            input.appendChild(optionElement);
                                        });
                                    } else {
                                        itemSchema.enum.forEach((option, idx) => {
                                            const optionElement = document.createElement('option');
                                            optionElement.value = option;
                                            if (itemSchema.enumNames) {
                                                optionElement.textContent = itemSchema.enumNames[idx];
                                            } else if (option.includes('(') && option.includes(')')) {
                                                optionElement.textContent = option;
                                            } else {
                                                optionElement.textContent = option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                                            }
                                            if (item === option) optionElement.selected = true;
                                            input.appendChild(optionElement);
                                        });
                                    }
                                } else {
                                    input = document.createElement('input');
                                    input.type = 'text';
                                    input.className = 'form-control';
                                    input.value = item;
                                }
                                
                                input.addEventListener('change', (e) => {
                                    if (Array.isArray(arrayData) && index < arrayData.length) {
                                        arrayData[index] = e.target.value;
                                        if (this.context.type === 'normal') {
                                            updateFormData();
                                            // Trigger validation for spatial fields when countries array changes
                                            if (name === 'spatial.countries') {
                                                this.context.validateField(name, arrayData, property);
                                                // Also validate scale field
                                                if (currentSchema?.properties?.spatial?.properties?.scale) {
                                                    this.context.validateField('spatial.scale', currentFormData.spatial?.scale, currentSchema.properties.spatial.properties.scale);
                                                }
                                            }
                                        }
                                    }
                                });
                            } else {
                                input = document.createElement('input');
                                input.type = 'text';
                                input.className = 'form-control';
                                input.value = item || '';
                                
                                input.addEventListener('change', (e) => {
                                    arrayData[index] = e.target.value;
                                    if (this.context.type === 'normal') {
                                        updateFormData();
                                        // Trigger validation for spatial fields when countries array changes
                                        if (name === 'spatial.countries') {
                                            this.context.validateField(name, arrayData, property);
                                            // Also validate scale field
                                            if (currentSchema?.properties?.spatial?.properties?.scale) {
                                                this.context.validateField('spatial.scale', currentFormData.spatial?.scale, currentSchema.properties.spatial.properties.scale);
                                            }
                                        }
                                    }
                                });
                            }
                            
                            const removeBtn = document.createElement('button');
                            removeBtn.type = 'button';
                            removeBtn.className = 'btn btn-outline-danger btn-sm';
                            removeBtn.textContent = '√ó';
                            removeBtn.addEventListener('click', () => {
                                arrayData.splice(index, 1);
                                renderArrayItems();
                                if (this.context.type === 'normal') {
                                    updateFormData();
                                    // Trigger validation for spatial fields when countries array changes
                                    if (name === 'spatial.countries') {
                                        this.context.validateField(name, arrayData, property);
                                        // Also validate scale field
                                        if (currentSchema?.properties?.spatial?.properties?.scale) {
                                            this.context.validateField('spatial.scale', currentFormData.spatial?.scale, currentSchema.properties.spatial.properties.scale);
                                        }
                                    }
                                }
                            });
                            
                            itemDiv.appendChild(input);
                            itemDiv.appendChild(removeBtn);
                            itemsContainer.appendChild(itemDiv);
                        });
                    }
                };
                
                const addBtn = document.createElement('button');
                addBtn.type = 'button';
                addBtn.className = 'btn btn-outline-primary btn-sm mb-2';
                addBtn.textContent = `+ Add ${property.title || name}`;
                addBtn.addEventListener('click', () => {
                    if (property.items.$ref || property.items.type === 'object') {
                        // Check if this is a problematic array that should be inline
                        const isProblematicArray = name.endsWith('.disaster_identifiers') ||
                                                 name === 'disaster_identifiers';

                        // For modal context or problematic arrays, add inline object instead of opening new modal
                        if (this.context.type === 'modal' || isProblematicArray) {
                            const newItem = {};
                            
                            // Initialize with appropriate ID based on object type
                            if (name === 'metrics') {
                                newItem.id = generateUniqueId('metric');
                            } else if (name === 'cost') {
                                newItem.id = generateUniqueId('cost');
                            } else if (name === 'hazards') {
                                newItem.id = generateUniqueId('hazard');
                            } else {
                                newItem.id = generateUniqueId('item');
                            }
                            
                            arrayData.push(newItem);
                            renderArrayItems();
                        } else {
                            openObjectEditor(name, arrayData.length, property.items, arrayData, renderArrayItems);
                        }
                    } else if (property.items.type === 'string') {
                        arrayData.push('');
                        renderArrayItems();
                        if (this.context.type === 'normal') {
                            updateFormData();
                            // Trigger validation for spatial fields when countries array changes
                            if (name === 'spatial.countries') {
                                this.context.validateField(name, arrayData, property);
                                // Also validate scale field
                                if (currentSchema?.properties?.spatial?.properties?.scale) {
                                    this.context.validateField('spatial.scale', currentFormData.spatial?.scale, currentSchema.properties.spatial.properties.scale);
                                }
                            }
                        }
                    } else {
                        arrayData.push({});
                        renderArrayItems();
                        if (this.context.type === 'normal') {
                            updateFormData();
                            // Trigger validation for spatial fields when countries array changes
                            if (name === 'spatial.countries') {
                                this.context.validateField(name, arrayData, property);
                                // Also validate scale field
                                if (currentSchema?.properties?.spatial?.properties?.scale) {
                                    this.context.validateField('spatial.scale', currentFormData.spatial?.scale, currentSchema.properties.spatial.properties.scale);
                                }
                            }
                        }
                    }
                });
                
                container.appendChild(addBtn);
                container.appendChild(itemsContainer);
                
                renderArrayItems();
                return container;
            }

            createInlineObjectEditor(item, index, arrayName, arrayProperty, arrayData, renderCallback) {
                const card = document.createElement('div');
                card.className = 'card mb-2';
                card.setAttribute('data-item-index', index);
                
                const cardBody = document.createElement('div');
                cardBody.className = 'card-body p-3';
                
                // Get the resolved schema for the object
                let itemSchema = arrayProperty.items;
                if (itemSchema && itemSchema.$ref) {
                    itemSchema = resolveReference(itemSchema.$ref);
                }
                
                // Create inline fields for properties
                if (itemSchema && itemSchema.properties) {
                    Object.entries(itemSchema.properties).forEach(([key, prop]) => {
                        if (key === 'id') return; // Skip ID field
                        
                        const fieldDiv = document.createElement('div');
                        fieldDiv.className = 'mb-2';
                        fieldDiv.setAttribute('data-field-name', key);
                        
                        // Create a sub-context for inline editing
                        const inlineContext = new FieldCreationContext('inline', fieldDiv);
                        const fieldElement = inlineContext.createField(key, prop, item[key]);

                        
                        // Set up change listener to update the item data
                        const input = fieldElement.querySelector('input, select, textarea');
                        if (input) {
                            // Set initial value if item has data
                            if (item[key] !== undefined) {
                                if (input.type === 'checkbox') {
                                    input.checked = item[key];
                                } else {
                                    input.value = item[key];
                                }
                            }
                            
                            input.addEventListener('change', (e) => {
                                const newValue = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
                                item[key] = newValue;
                                console.log(`Updated ${arrayName}[${index}].${key} = ${newValue}`);
                                
                                // Handle currency field dependencies for exposure metrics
                                if (key === 'quantity_kind' && newValue === 'monetary') {
                                    // Find currency field in the same card and enable it
                                    const currencyField = card.querySelector('[data-field-name="currency"]');
                                    if (currencyField) {
                                        const currencyInput = currencyField.querySelector('select, input');
                                        if (currencyInput) {
                                            currencyInput.disabled = false;
                                            currencyInput.required = true;
                                        }
                                        const label = currencyField.querySelector('label');
                                        if (label && !label.innerHTML.includes('*')) {
                                            label.innerHTML += ' <span class="text-danger">*</span>';
                                        }
                                    }
                                } else if (key === 'quantity_kind' && newValue !== 'monetary') {
                                    const currencyField = card.querySelector('[data-field-name="currency"]');
                                    if (currencyField) {
                                        const currencyInput = currencyField.querySelector('select, input');
                                        if (currencyInput) {
                                            currencyInput.disabled = true;
                                            currencyInput.required = false;
                                            currencyInput.value = '';
                                            item.currency = '';
                                        }
                                        const label = currencyField.querySelector('label');
                                        if (label) {
                                            label.innerHTML = label.innerHTML.replace(' <span class="text-danger">*</span>', '');
                                        }
                                    }
                                }
                            });
                        }
                        
                        fieldDiv.appendChild(fieldElement);
                        cardBody.appendChild(fieldDiv);

                        // DIRECT FIX: Add currency field immediately after quantity_kind in array cards
                        if (key === 'quantity_kind') {
                            const currencyDiv = document.createElement('div');
                            currencyDiv.className = 'mb-2';
                            currencyDiv.setAttribute('data-field-name', 'currency');

                            const currencyProperty = {
                                "type": "string",
                                "enum": ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "CNY", "SEK", "NOK", "DKK", "PLN", "CZK", "HUF", "RON", "BGN", "HRK"],
                                "title": "Currency"
                            };

                            const currencyContext = new FieldCreationContext('inline', currencyDiv);
                            const savedCurrencyValue = item['currency'];
                            const currencyElement = currencyContext.createField('currency', currencyProperty, savedCurrencyValue);
                            currencyDiv.appendChild(currencyElement);

                            // Ensure currency value is properly set after field creation
                            if (savedCurrencyValue) {
                                setTimeout(() => {
                                    const currencyInput = currencyElement.querySelector('select, input');
                                    if (currencyInput && currencyInput.value !== savedCurrencyValue) {
                                        currencyInput.value = savedCurrencyValue;
                                    }
                                }, 100);
                            }

                            // Add currency field right after the quantity_kind field
                            cardBody.appendChild(currencyDiv);

                            // Currency field will be handled by the unified dependency system
                        }
                    });
                }
                
                // Action buttons
                const actions = document.createElement('div');
                actions.className = 'd-flex justify-content-end gap-2 mt-2';
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-outline-danger btn-sm';
                removeBtn.textContent = 'üóëÔ∏è Remove';
                removeBtn.addEventListener('click', () => {
                    arrayData.splice(index, 1);
                    renderCallback();
                });
                
                actions.appendChild(removeBtn);
                cardBody.appendChild(actions);
                
                card.appendChild(cardBody);
                
                // Handle currency field visibility after card is created
                setTimeout(() => {
                    const quantityKindField = card.querySelector('[data-field-name="quantity_kind"] select, [data-field-name="quantity_kind"] input');
                    const currencyField = card.querySelector('[data-field-name="currency"]');
                    
                    if (quantityKindField && currencyField) {
                        const currentValue = item.quantity_kind || quantityKindField.value;
                        const currencyInput = currencyField.querySelector('select, input');
                        if (currentValue === 'monetary') {
                            if (currencyInput) {
                                currencyInput.disabled = false;
                                currencyInput.required = true;
                            }
                            const label = currencyField.querySelector('label');
                            if (label && !label.innerHTML.includes('*')) {
                                label.innerHTML += ' <span class="text-danger">*</span>';
                            }
                        } else {
                            if (currencyInput) {
                                currencyInput.disabled = true;
                                currencyInput.required = false;
                                // Don't clear the value during initial setup - only when user changes quantity_kind
                                // The value clearing will be handled by user interaction events
                            }
                        }
                    }
                }, 50);
                
                return card;
            }

            createObjectInput(name, property, value, options) {
                const container = document.createElement('div');
                container.className = 'object-field';

                const isDirectFormProperty = !name.includes('.') || name.split('.').length <= 2;
                const isSpatialField = name === 'spatial';
                const isGeometryField = name.endsWith('.geometry');
                const isClassificationField = name.endsWith('.se_indicator') || name === 'se_indicator';

                // Always show title for spatial field, geometry sub-field, classification fields, or for nested objects
                if (!isDirectFormProperty || isSpatialField || isGeometryField || isClassificationField) {
                    const title = document.createElement('h6');
                    title.textContent = property.title || name;
                    title.className = 'mb-3';

                    // Add some styling for main spatial section
                    if (isSpatialField) {
                        title.className = 'mb-3 mt-3';
                        title.style.borderBottom = '1px solid #dee2e6';
                        title.style.paddingBottom = '0.5rem';
                    }

                    container.appendChild(title);
                }
                
                if (property.properties) {
                    Object.entries(property.properties).forEach(([key, prop]) => {
                        const fieldValue = value && value[key] ? value[key] : null;
                        const subContext = new FieldCreationContext(this.context.type, this.context.container);
                        const field = subContext.createField(`${name}.${key}`, prop, fieldValue, options);
                        container.appendChild(field);
                    });
                }
                
                return container;
            }

            addValidationIndicator(container, name) {
                const validationIndicator = document.createElement('span');
                validationIndicator.className = 'validation-indicator';
                validationIndicator.id = `validation-${name}`;
                container.appendChild(validationIndicator);
            }

            addExamples(container, property) {
                if (property.examples && property.examples.length > 0) {
                    const hint = document.createElement('div');
                    hint.className = 'field-hint';
                    hint.innerHTML = `<strong>Examples:</strong> ${property.examples.slice(0, 3).join(', ')}`;
                    container.appendChild(hint);
                }
            }

            handleDependencies(container, name, property, value) {
                // Special handling for currency field - always show but disable unless quantity_kind is 'monetary'
                if (name.includes('currency') || name === 'currency') {
                    const currencyInput = container.querySelector('select, input');
                    if (currencyInput) {
                        currencyInput.disabled = true; // Default to disabled

                        // Find the related quantity_kind field name
                        let quantityKindFieldName = null;
                        if (name.includes('impact_and_losses')) {
                            quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                        } else if (name.includes('metrics')) {
                            quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                        } else if (name.includes('losses.impact_and_losses')) {
                            quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                        } else {
                            quantityKindFieldName = name.replace(/currency$/, 'quantity_kind');
                        }

                        // Helper to update currency field state
                        function updateCurrencyState() {
                            const qkValue = getNestedValue(currentFormData, quantityKindFieldName);
                            if (qkValue === 'monetary') {
                                currencyInput.disabled = false;
                                currencyInput.required = true;
                            } else {
                                currencyInput.disabled = true;
                                currencyInput.required = false;
                                currencyInput.value = '';
                            }
                        }

                        // Initial check - ensure currency starts disabled unless quantity_kind is monetary
                        setTimeout(() => {
                            const currentValue = getNestedValue(currentFormData, quantityKindFieldName) || '';
                            currencyInput.disabled = currentValue !== 'monetary';
                            currencyInput.required = currentValue === 'monetary';
                            if (currentValue !== 'monetary') {
                                currencyInput.value = '';
                            }
                            updateCurrencyState();
                        }, 0);

                        // Listen for changes on the related quantity_kind field
                        setTimeout(() => {
                            const qkInput = document.getElementById(this.context.getFieldId(quantityKindFieldName));
                            if (qkInput) {
                                // Listen to all relevant events for complete dropdown/typing support
                                qkInput.addEventListener('change', updateCurrencyState);
                                qkInput.addEventListener('input', updateCurrencyState);
                                if (qkInput.tagName === 'SELECT') {
                                    qkInput.addEventListener('click', updateCurrencyState);
                                }
                            }
                        }, 100);
                    }
                }
            }

            resolveSchemaRef(ref) {
                if (!ref || !ref.startsWith('#/$defs/')) return null;
                if (!currentSchema || !currentSchema.$defs) {
                    console.warn('Schema not loaded yet, cannot resolve ref:', ref);
                    return null;
                }
                const defName = ref.replace('#/$defs/', '');
                return currentSchema.$defs[defName] || null;
            }

            isRequiredField(name, property, options) {
                // Spatial scale is always mandatory when spatial coverage is included
                if (name === 'spatial.scale') {
                    return true;
                }

                // The spatial section itself should NOT have red bar
                if (name === 'spatial') {
                    return false;
                }

                // Other spatial fields are NOT mandatory (except countries, which depends on scale)
                // Only spatial.scale should show the red bar
                if (name.startsWith('spatial.') && name !== 'spatial.scale' && name !== 'spatial.countries') {
                    return false;
                }

                // spatial.countries is not directly required (its requirement depends on scale value)
                if (name === 'spatial.countries') {
                    return false;
                }

                // For modal context (array item editors), we need to check the item schema
                if (this.context.type === 'modal' && currentObjectEditor && currentObjectEditor.arrayName) {
                    const arrayName = currentObjectEditor.arrayName;

                    // Navigate to the array schema (handle nested paths like "loss.losses")
                    const arrayParts = arrayName.split('.');
                    let arraySchema = currentSchema.properties;

                    // Navigate through the nested path
                    for (const part of arrayParts) {
                        if (arraySchema && arraySchema[part]) {
                            arraySchema = arraySchema[part];
                        } else if (arraySchema && arraySchema.properties && arraySchema.properties[part]) {
                            // Check in properties for object schemas
                            arraySchema = arraySchema.properties[part];
                        } else {
                            arraySchema = null;
                            break;
                        }
                    }

                    let itemSchema = null;

                    // Handle direct items schema or $ref
                    if (arraySchema && arraySchema.items) {
                        if (arraySchema.items.$ref) {
                            itemSchema = this.resolveSchemaRef(arraySchema.items.$ref);
                        } else {
                            itemSchema = arraySchema.items;
                        }
                    }

                    // Check if this field is required in the item schema
                    if (itemSchema && itemSchema.required && itemSchema.required.includes(name)) {
                        return true;
                    }

                    // Handle nested required fields (like impact_and_losses fields in loss items)
                    if (name.includes('.') && itemSchema && itemSchema.properties) {
                        const parts = name.split('.');
                        const fieldName = parts[parts.length - 1];

                        let current = itemSchema;
                        for (let i = 0; i < parts.length - 1; i++) {
                            if (current.properties && current.properties[parts[i]]) {
                                current = current.properties[parts[i]];
                            }
                        }

                        if (current && current.required && current.required.includes(fieldName)) {
                            return true;
                        }
                    }

                    // Check if field is required in nested objects (for modal contexts where field names are flattened)
                    if (itemSchema && itemSchema.properties) {
                        for (const [propName, propSchema] of Object.entries(itemSchema.properties)) {
                            if (propSchema.type === 'object' && propSchema.required && propSchema.required.includes(name)) {
                                return true;
                            }
                        }
                    }
                }

                // Check top-level required fields (general section)
                if (currentSchema.required && currentSchema.required.includes(name)) {
                    return true;
                }

                // Check section-specific required fields
                if (name.includes('.')) {
                    const parts = name.split('.');
                    const sectionName = parts[0];
                    const fieldName = parts[parts.length - 1];

                    // Check if this section has a schema with required fields
                    if (currentSchema.properties && currentSchema.properties[sectionName]) {
                        const sectionSchema = currentSchema.properties[sectionName];

                        // For nested object fields (e.g., project.name), only mark as required
                        // if the parent object itself is required at the dataset level
                        if (sectionSchema.type === 'object' && sectionSchema.required && sectionSchema.required.includes(fieldName)) {
                            // Check if parent object is required at dataset level
                            const isParentRequired = currentSchema.required && currentSchema.required.includes(sectionName);
                            if (isParentRequired) {
                                return true;
                            }
                            // If parent is not required at dataset level, nested field is also not required
                            return false;
                        }

                        // Direct section required fields (for non-object types)
                        if (sectionSchema.required && sectionSchema.required.includes(fieldName)) {
                            return true;
                        }

                        // For nested objects (like exposure items, loss items, etc.)
                        if (sectionSchema.type === 'array' && sectionSchema.items) {
                            let itemsSchema = sectionSchema.items;

                            // Resolve $ref if present
                            if (itemsSchema.$ref) {
                                itemsSchema = this.resolveSchemaRef(itemsSchema.$ref);
                            }

                            if (itemsSchema && itemsSchema.required && itemsSchema.required.includes(fieldName)) {
                                return true;
                            }
                        }

                        // For complex nested paths (like loss.losses.*)
                        if (parts.length > 2 && sectionSchema.properties) {
                            let current = sectionSchema;
                            for (let i = 1; i < parts.length - 1; i++) {
                                if (current.properties && current.properties[parts[i]]) {
                                    current = current.properties[parts[i]];
                                    // Handle items with $ref (like loss.losses items)
                                    if (current.items) {
                                        if (current.items.$ref) {
                                            current = this.resolveSchemaRef(current.items.$ref);
                                        } else {
                                            current = current.items;
                                        }
                                    }
                                } else if (current.items) {
                                    if (current.items.$ref) {
                                        current = this.resolveSchemaRef(current.items.$ref);
                                    } else {
                                        current = current.items;
                                    }
                                }
                            }
                            if (current && current.required && current.required.includes(fieldName)) {
                                return true;
                            }
                        }
                    }
                }

                // Currency field is required only when impact_unit is monetary
                if (name.includes('currency') && name.includes('impact_and_losses')) {
                    const parentPath = name.replace('currency', 'impact_unit');
                    const parentValue = getNestedValue(currentFormData, parentPath);
                    return parentValue === 'monetary';
                }

                return false;
            }

            setupAutoComplete(input, fieldName, property) {
                let suggestions = [];
                
                if (property.suggestions && property.suggestions.length > 0) {
                    suggestions = [...property.suggestions];
                }
                
                if (property.examples && property.examples.length > 0) {
                    suggestions = [...suggestions, ...property.examples];
                }
                
                if (AUTO_COMPLETE_SUGGESTIONS[fieldName]) {
                    suggestions = [...suggestions, ...AUTO_COMPLETE_SUGGESTIONS[fieldName]];
                }
                
                suggestions = [...new Set(suggestions)];
                
                if (suggestions.length === 0) return;

                const container = input.parentElement;
                let suggestionContainer = container;
                if (container.classList.contains('input-group')) {
                    suggestionContainer = container.parentElement;
                }
                
                if (!suggestionContainer) return;
                
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions';
                suggestionContainer.appendChild(suggestionsDiv);

                input.addEventListener('input', function() {
                    const value = this.value.toLowerCase();
                    const matches = suggestions.filter(s => s.toLowerCase().includes(value));
                    
                    if (matches.length > 0 && value.length > 0) {
                        suggestionsDiv.innerHTML = '';
                        matches.slice(0, 8).forEach(match => {
                            const div = document.createElement('div');
                            div.className = 'autocomplete-suggestion';
                            div.textContent = match;
                            div.addEventListener('click', () => {
                                input.value = match;
                                suggestionsDiv.style.display = 'none';
                                updateFormData();
                            });
                            suggestionsDiv.appendChild(div);
                        });
                        suggestionsDiv.style.display = 'block';
                    } else {
                        suggestionsDiv.style.display = 'none';
                    }
                });

                input.addEventListener('blur', function() {
                    setTimeout(() => {
                        suggestionsDiv.style.display = 'none';
                    }, 150);
                });
            }
        }

        /**
         * Unified Event Handler
         * Handles events consistently across all contexts
         */
        class UnifiedEventHandler {
            constructor(context) {
                this.context = context;
            }

            setupListeners(element, name, property, options = {}) {
                const eventHandler = (e) => {
                    this.handleFieldChange(e, name, property, options);
                };

                if (element.tagName === 'SELECT') {
                    // For SELECT elements, listen to both 'change' and 'input' for immediate dropdown response
                    element.addEventListener('change', eventHandler);
                    element.addEventListener('input', eventHandler);
                } else if (element.type === 'checkbox') {
                    element.addEventListener('change', eventHandler);
                } else {
                    element.addEventListener('input', eventHandler);
                }
            }

            // getEventType method removed - event handling now done directly in setupListeners

            handleFieldChange(event, name, property, options) {
                const value = this.getFieldValue(event.target);

                // Update form data
                if (this.context.type === 'normal') {
                    updateFormData();
                } else if (this.context.type === 'modal') {
                    // Handle modal-specific updates
                    this.handleModalFieldChange(name, value, property);
                }

                // Validate field
                this.context.validateField(name, value, property);

                // Cross-validate spatial fields (scale and countries are interdependent)
                if (name === 'spatial.scale' || name === 'spatial.countries') {
                    const relatedField = name === 'spatial.scale' ? 'spatial.countries' : 'spatial.scale';
                    const relatedValue = name === 'spatial.scale'
                        ? currentFormData.spatial?.countries
                        : currentFormData.spatial?.scale;

                    // Find the related field's property definition
                    if (currentSchema?.properties?.spatial?.properties) {
                        const relatedFieldName = relatedField.split('.')[1];
                        const relatedProperty = currentSchema.properties.spatial.properties[relatedFieldName];
                        if (relatedProperty) {
                            this.context.validateField(relatedField, relatedValue, relatedProperty);
                        }
                    }
                }

                // Handle dependencies
                this.handleDependentFields(name, value, event.target);
            }

            getFieldValue(element) {
                if (element.type === 'checkbox') return element.checked;
                return element.value;
            }

            handleModalFieldChange(name, value, property) {
                // Modal-specific data handling can be added here
                console.log(`Modal field changed: ${name} = ${value}`);
            }

            handleDependentFields(changedFieldName, newValue, element) {
                // Handle field dependencies
                const dependents = this.findDependentFields(changedFieldName);

                dependents.forEach(dependentFieldName => {
                    const dependentFieldId = this.context.getFieldId(dependentFieldName);
                    const dependentField = document.getElementById(dependentFieldId);

                    if (dependentField) {
                        if (dependentFieldName.includes('hazard_process') || dependentFieldName.includes('processes')) {
                            this.rebuildDependentDropdown(dependentField, dependentFieldName, newValue);
                        } else if (dependentFieldName.includes('currency')) {
                            this.toggleCurrencyField(dependentField, newValue);
                        }
                    }
                });

                // Special handling for hazard type changes to filter IMT options
                const isHazardTypeField = (changedFieldName.includes('type') && !changedFieldName.includes('impact_unit') && !changedFieldName.includes('risk_data_type')) ||
                                        changedFieldName.includes('hazard_primary') ||
                                        changedFieldName.includes('hazard_secondary') ||
                                        changedFieldName.includes('hazard_type');

                if (isHazardTypeField) {
                    // This is a hazard type field change that should trigger IMT filtering
                    const isRelevantHazardField = changedFieldName === 'hazards.type' ||
                                                changedFieldName === 'type' ||
                                                changedFieldName === 'vulnerability.hazard_primary' ||
                                                changedFieldName === 'vulnerability.hazard_secondary' ||
                                                changedFieldName === 'hazard_primary' ||
                                                changedFieldName === 'hazard_secondary' ||
                                                changedFieldName.includes('hazard_type');

                    if (isRelevantHazardField) {
                        console.log(`Hazard type changed: ${changedFieldName} = ${newValue}`);
                        updateIMTOptionsForHazard(newValue);
                    }
                }

                // Special handling for impact_unit field to show/hide currency
                if (changedFieldName.includes('impact_unit') || (this.context.type === 'modal' && changedFieldName === 'impact_unit')) {
                    let currencyFieldName;
                    if (this.context.type === 'modal') {
                        currencyFieldName = 'currency';
                    } else {
                        currencyFieldName = changedFieldName.replace('impact_unit', 'currency');
                    }
                    
                    const currencyField = document.getElementById(this.context.getFieldId(currencyFieldName));
                    
                    console.log(`Impact unit changed: ${changedFieldName} = ${newValue}`);
                    console.log(`Looking for currency field: ${this.context.getFieldId(currencyFieldName)}`);
                    console.log(`Currency field found:`, !!currencyField);
                    
                    if (currencyField) {
                        this.toggleCurrencyFieldContainer(currencyField.closest('.form-field, .modal-form-field'), newValue);
                    }
                }

                // Special handling for quantity_kind field to show/hide currency
                if (changedFieldName.includes('quantity_kind') || (this.context.type === 'modal' && changedFieldName === 'quantity_kind')) {
                    let currencyFieldName;
                    if (this.context.type === 'modal') {
                        // For modal context, try to preserve the full path structure
                        if (changedFieldName.includes('.')) {
                            currencyFieldName = changedFieldName.replace('quantity_kind', 'currency');
                        } else {
                            currencyFieldName = 'currency';
                        }
                    } else {
                        currencyFieldName = changedFieldName.replace('quantity_kind', 'currency');
                    }

                    const currencyField = document.getElementById(this.context.getFieldId(currencyFieldName));

                    if (currencyField) {
                        const container = currencyField.closest('.form-field, .modal-form-field');
                        if (container) {
                            this.toggleCurrencyFieldContainer(container, newValue);
                        } else {
                            // Fallback: handle the field directly if no container found
                            this.toggleCurrencyField(currencyField, newValue);
                        }

                        // Also ensure the field state is properly set regardless of container
                        if (newValue === 'monetary') {
                            currencyField.disabled = false;
                            currencyField.required = true;
                        } else {
                            currencyField.disabled = true;
                            currencyField.required = false;
                            // Only clear value during user interactions, not initial setup
                            if (newValue !== undefined && newValue !== null) {
                                currencyField.value = '';
                            }
                        }
                    }
                }

                // Special handling for license field to show/hide license_url
                if (changedFieldName === 'license') {
                    const licenseUrlField = document.getElementById(this.context.getFieldId('license_url'));

                    if (licenseUrlField) {
                        const container = licenseUrlField.closest('.form-field, .modal-form-field');
                        if (container) {
                            // Show license_url field only when license is "Custom"
                            if (newValue === 'Custom') {
                                container.style.display = 'block';
                                licenseUrlField.disabled = false;
                                licenseUrlField.required = true;
                                licenseUrlField.classList.add('required');
                            } else {
                                container.style.display = 'none';
                                licenseUrlField.disabled = true;
                                licenseUrlField.required = false;
                                licenseUrlField.classList.remove('required');
                                licenseUrlField.value = '';
                            }
                        }
                    }
                }

                // Special handling for hazard type changes to update processes
                if (changedFieldName.includes('hazard_type') || changedFieldName.includes('type') ||
                    (this.context.type === 'modal' && changedFieldName === 'type')) {
                    
                    let processFieldName;
                    if (this.context.type === 'modal') {
                        processFieldName = 'processes';
                    } else if (changedFieldName.includes('hazard_type')) {
                        processFieldName = changedFieldName.replace('hazard_type', 'hazard_process');
                    } else {
                        // This covers hazards.type -> hazards.processes
                        processFieldName = changedFieldName.replace('type', 'processes');
                    }
                    
                    const processField = document.getElementById(this.context.getFieldId(processFieldName));
                    
                    console.log(`Hazard type changed: ${changedFieldName} = ${newValue}`);
                    console.log(`Looking for process field: ${this.context.getFieldId(processFieldName)}`);
                    console.log(`Process field found:`, !!processField);
                    
                    if (processField) {
                        this.rebuildDependentDropdown(processField, processFieldName, newValue);
                    }
                }
            }

            findDependentFields(parentFieldName) {
                const dependents = [];
                Object.entries(FIELD_DEPENDENCIES).forEach(([dependent, parent]) => {
                    if (parent === parentFieldName) {
                        dependents.push(dependent);
                    }
                });
                return dependents;
            }

            rebuildDependentDropdown(selectElement, fieldName, parentValue) {
                if (!parentValue) return;
                
                console.log(`Rebuilding dropdown: ${fieldName} based on parent value: ${parentValue}`);
                
                const currentValue = selectElement.value;
                
                // Clear existing options
                selectElement.innerHTML = '';
                
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select an option...';
                selectElement.appendChild(emptyOption);
                
                // Get available options based on parent value
                let availableOptions = [];
                
                if ((fieldName.includes('process') || fieldName === 'processes') && currentSchema.hazard_process_mappings) {
                    availableOptions = currentSchema.hazard_process_mappings[parentValue] || [];
                    console.log(`Found ${availableOptions.length} process options for "${parentValue}":`, availableOptions);
                }
                
                // Populate new options
                availableOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    // Check if option contains parentheses (e.g., "CSV (csv)") and preserve as-is
                    if (option.includes('(') && option.includes(')')) {
                        optionElement.textContent = option;
                    } else {
                        optionElement.textContent = option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }

                    if (currentValue === option) {
                        optionElement.selected = true;
                    }
                    
                    selectElement.appendChild(optionElement);
                });
                
                // If previous selection is no longer valid, clear it
                if (currentValue && !availableOptions.includes(currentValue)) {
                    selectElement.value = '';
                    selectElement.dispatchEvent(new Event('change'));
                }
            }

            toggleCurrencyField(currencyField, impactUnitValue) {
                // This method handles the field element directly - use disabled instead of hiding
                if (impactUnitValue === 'monetary') {
                    currencyField.disabled = false;
                    currencyField.required = true;
                } else {
                    currencyField.disabled = true;
                    currencyField.required = false;
                    currencyField.value = '';
                }
            }

            toggleCurrencyFieldContainer(container, quantityKindValue) {
                // This method handles the container (form-field div) - use disabled instead of hiding
                const label = container.querySelector('label');
                const input = container.querySelector('select, input');

                if (quantityKindValue === 'monetary') {
                    if (input) {
                        input.disabled = false;
                        input.required = true;
                    }

                    if (label && !label.innerHTML.includes('*')) {
                        label.innerHTML += ' <span class="text-danger">*</span>';
                        container.classList.add('required');
                    }
                } else {
                    if (input) {
                        input.disabled = true;
                        input.required = false;
                        input.value = '';
                    }

                    if (label) {
                        label.innerHTML = label.innerHTML.replace(' <span class="text-danger">*</span>', '');
                        container.classList.remove('required');
                    }
                }
            }
        }

        /**
         * Unified Field Validator
         * Handles validation consistently across all contexts
         */
        class UnifiedFieldValidator {
            constructor(context) {
                this.context = context;
            }

            validate(fieldName, value, property) {
                let isValid = true;
                let errorMessage = '';

                // Check if this is a required field from schema
                const isSchemaRequired = currentSchema.required && currentSchema.required.includes(fieldName);

                // Special handling for spatial.scale which is always mandatory
                if (fieldName === 'spatial.scale') {
                    if (!value || (typeof value === 'string' && value.trim() === '')) {
                        isValid = false;
                        errorMessage = 'Required field';
                    }
                }
                // Check other schema-required fields - handle both strings and arrays
                else if (isSchemaRequired) {
                    if (!value || (typeof value === 'string' && value.trim() === '') || (Array.isArray(value) && value.length === 0)) {
                        isValid = false;
                        errorMessage = 'Required field';
                    }
                }

                // Format and length validations
                if (value && typeof value === 'string') {
                    if (property.minLength && value.length < property.minLength) {
                        isValid = false;
                        errorMessage = `Minimum ${property.minLength} characters`;
                    }
                    if (property.format === 'email' && value && !this.isValidEmail(value)) {
                        isValid = false;
                        errorMessage = 'Invalid email format';
                    }
                    if (property.format === 'iri' && value && !this.isValidUrl(value)) {
                        isValid = false;
                        errorMessage = 'Invalid URL format';
                    }
                }

                // Spatial scale and countries validation (only if no errors yet)
                if (isValid) {
                    const spatialValidation = this.validateSpatialRelationship(fieldName, value);
                    if (!spatialValidation.isValid) {
                        isValid = false;
                        errorMessage = spatialValidation.errorMessage;
                    }
                }

                // Only update validation indicators for normal context
                if (this.context.type === 'normal') {
                    fieldValidationStatus.set(fieldName, { isValid, errorMessage });
                    this.updateValidationIndicator(fieldName, isValid, errorMessage);
                    updateValidationDisplay();
                }

                return { isValid, errorMessage };
            }

            validateSpatialRelationship(fieldName, value) {
                let isValid = true;
                let errorMessage = '';

                // Check if we're validating spatial.scale or spatial.countries
                if (fieldName === 'spatial.scale' || fieldName === 'spatial.countries') {
                    // Get scale - use passed value if validating scale, otherwise get from currentFormData
                    let scale;
                    if (fieldName === 'spatial.scale') {
                        scale = value;
                    } else {
                        scale = currentFormData.spatial?.scale;
                    }

                    // Get countries - use passed value if validating countries, otherwise get from currentFormData
                    let countries;
                    if (fieldName === 'spatial.countries') {
                        // When validating countries, the value passed is the array
                        countries = value;
                    } else {
                        // When validating scale, get countries from currentFormData
                        countries = currentFormData.spatial?.countries;
                    }

                    if (scale) {
                        // Filter out empty strings and count only non-empty country codes
                        const validCountries = Array.isArray(countries)
                            ? countries.filter(c => c && typeof c === 'string' && c.trim() !== '')
                            : [];
                        const countriesCount = validCountries.length;

                        switch (scale.toLowerCase()) {
                            case 'global':
                                // Global scale: no country specification needed
                                break;
                            case 'regional':
                                // Regional scale: at least 2 countries expected
                                if (countriesCount < 2) {
                                    isValid = false;
                                    errorMessage = fieldName === 'spatial.scale'
                                        ? 'Regional scale requires at least 2 countries'
                                        : 'At least 2 countries required for regional scale';
                                }
                                break;
                            case 'national':
                            case 'sub-national':
                                // National or sub-national: at least 1 country expected
                                if (countriesCount < 1) {
                                    isValid = false;
                                    errorMessage = fieldName === 'spatial.scale'
                                        ? `${scale} scale requires at least 1 country`
                                        : `At least 1 country required for ${scale} scale`;
                                }
                                break;
                        }
                    }
                }

                return { isValid, errorMessage };
            }

            updateValidationIndicator(fieldName, isValid, errorMessage) {
                const indicator = document.getElementById(`validation-${fieldName}`);
                if (indicator) {
                    if (isValid) {
                        indicator.className = 'validation-indicator valid';
                        indicator.textContent = '‚úì';
                        indicator.title = 'Valid';
                    } else {
                        indicator.className = 'validation-indicator invalid';
                        indicator.textContent = '‚úó';
                        indicator.title = errorMessage;
                    }
                }
            }

            isValidEmail(email) {
                return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
            }

            isValidUrl(url) {
                try {
                    new URL(url);
                    return true;
                } catch {
                    return false;
                }
            }
        }

        // ================================
        // MAIN APPLICATION LOGIC
        // ================================

        // Auto-ID generation
        function generateUniqueId(prefix = 'item') {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return `${prefix}_${result}`;
        }

        // Direct currency monitoring system removed - unified system now handles everything

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            loadSchemaVersions();
            loadFromStorage();
            loadCountryNames();
            updateRiskDataType();
        });

        function setupEventListeners() {
            // Schema version selection
            document.getElementById('schemaVersionSelect').addEventListener('change', loadSelectedSchema);

            // Section checkboxes
            SECTIONS.forEach(section => {
                document.getElementById(`${section}Check`).addEventListener('change', function() {
                    if (this.checked) {
                        activeSections.add(section);
                        addSectionTab(section);
                    } else {
                        activeSections.delete(section);
                        removeSectionTab(section);
                    }
                    updateFormData();
                    updateRiskDataType();
                    generateForm();
                });
            });

            // File upload
            document.getElementById('schemaDropZone').addEventListener('click', () => 
                document.getElementById('schemaFile').click()
            );
            document.getElementById('schemaFile').addEventListener('change', handleSchemaFile);
            
            // Drag and drop
            setupDragAndDrop();

            // Buttons
            document.getElementById('exportJson').addEventListener('click', exportJson);
            document.getElementById('exportXml').addEventListener('click', exportXml);
            document.getElementById('saveProgress').addEventListener('click', saveProgress);
            document.getElementById('loadData').addEventListener('click', loadData);
            document.getElementById('validateForm').addEventListener('click', validateForm);
            document.getElementById('resetForm').addEventListener('click', resetForm);
            document.getElementById('publishGitHub').addEventListener('click', openGithubConfig);

            // GitHub modal event listeners
            document.getElementById('testGithubConnection').addEventListener('click', testGithubConnection);
            document.getElementById('publishToGithub').addEventListener('click', publishToGithub);

            // Object editor modal
            document.getElementById('saveObjectBtn').addEventListener('click', saveCurrentObject);
        }

        function loadSchemaVersions() {
            const select = document.getElementById('schemaVersionSelect');
            select.innerHTML = '<option value="">Select RDLS version...</option>';
            
            Object.keys(RDLS_VERSIONS).forEach(version => {
                const option = document.createElement('option');
                option.value = version;
                const isLatest = version === '0.3';
                option.textContent = `RDLS ${version}${isLatest ? ' (dev)' : ''}`;
                select.appendChild(option);
            });
            
            // Auto-select the latest version
            select.value = '0.3';
            loadSelectedSchema();
        }

        async function loadSelectedSchema() {
            const version = document.getElementById('schemaVersionSelect').value;
            if (!version) return;

            updateSchemaStatus('Loading schema...', 'text-info');
            
            try {
                const response = await fetch(RDLS_VERSIONS[version]);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                currentSchema = await response.json();

                // Add currency field definitions where needed - comprehensive search
                function addCurrencyFields(obj, path = '') {
                    if (!obj || typeof obj !== 'object') return;

                    for (const key in obj) {
                        if (obj[key] && typeof obj[key] === 'object') {
                            // Check if this is a properties object containing quantity_kind
                            if (key === 'properties' && obj[key].quantity_kind) {
                                console.log(`Adding currency field at: ${path}.${key}`);
                                obj[key].currency = {
                                    "type": "string",
                                    "enum": ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "CNY", "SEK", "NOK", "DKK", "PLN", "CZK", "HUF", "RON", "BGN", "HRK"],
                                    "title": "Currency"
                                };
                            }

                            // Also check if this object directly contains quantity_kind (for different schema structures)
                            if (obj[key].quantity_kind && !obj[key].currency) {
                                console.log(`Adding currency field directly at: ${path}.${key}`);
                                obj[key].currency = {
                                    "type": "string",
                                    "enum": ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "CNY", "SEK", "NOK", "DKK", "PLN", "CZK", "HUF", "RON", "BGN", "HRK"],
                                    "title": "Currency"
                                };
                            }

                            // Recurse into nested objects
                            addCurrencyFields(obj[key], path ? `${path}.${key}` : key);
                        }
                    }
                }

                console.log('Using direct currency field insertion during form generation');

                // Ensure mappings are available
                if (!currentSchema.hazard_process_mappings) {
                    currentSchema.hazard_process_mappings = {
                        "drought": ["agricultural_drought", "hydrological_drought", "meteorological_drought", "socioeconomic_drought"],
                        "flood": ["fluvial_flood", "pluvial_flood", "groundwater_flood", "coastal_flood"],
                        "earthquake": ["primary_rupture", "secondary_rupture", "ground_motion", "liquefaction"],
                        "extreme_temperature": ["extreme_cold", "extreme_heat"],
                        "strong_wind": ["extratropical_cyclone", "tropical_cyclone", "tornado"],
                        "wildfire": ["wildfire"],
                        "landslide": ["snow_avalanche", "landslide_general", "landslide_rockslide", "landslide_mudflow", "landslide_rockfall"],
                        "tsunami": ["tsunami"],
                        "volcanic": ["ashfall", "volcano_ballistics", "lahar", "lava", "pyroclastic_flow"],
                        "coastal_flood": ["coastal_flood", "storm_surge"],
                        "convective_storm": ["tornado"]
                    };
                }

                // Load IMT definitions from schema
                if (currentSchema.intensity_measure_definitions) {
                    IMT_DEFINITIONS = currentSchema.intensity_measure_definitions;
                    console.log('Loaded', Object.keys(IMT_DEFINITIONS).length, 'IMT definitions from schema');
                }

                // Load IMT mappings from schema (or use legacy if not available)
                if (currentSchema.intensity_measure_mappings) {
                    // Convert simple code arrays from schema to objects with titles and descriptions
                    HAZARD_IMT_MAPPING = {};
                    for (const [hazardType, imtCodes] of Object.entries(currentSchema.intensity_measure_mappings)) {
                        // Handle universal metrics separately
                        if (hazardType === 'universal') {
                            UNIVERSAL_IMTS = imtCodes.map(code => {
                                const def = IMT_DEFINITIONS[code];
                                return {
                                    code: code,
                                    title: def ? def.title : code,
                                    description: def ? def.description : ''
                                };
                            });
                        } else {
                            HAZARD_IMT_MAPPING[hazardType] = imtCodes.map(code => {
                                const def = IMT_DEFINITIONS[code];
                                return {
                                    code: code,
                                    title: def ? def.title : code,
                                    description: def ? def.description : ''
                                };
                            });
                        }
                    }
                    console.log('Loaded IMT mappings from schema');
                } else {
                    HAZARD_IMT_MAPPING = LEGACY_HAZARD_IMT_MAPPING;
                    console.log('Using legacy IMT mappings');
                }

                // Reset form data when switching schema versions
                currentFormData = {};
                fieldValidationStatus.clear();

                updateSchemaStatus(`‚úì RDLS ${version} loaded`, 'text-success');
                generateForm();
            } catch (error) {
                updateSchemaStatus(`‚úó Failed to load schema: ${error.message}`, 'text-danger');
                console.error('Schema loading error:', error);
            }
        }

        function updateSchemaStatus(message, className) {
            const status = document.getElementById('schemaStatus');
            status.textContent = message;
            status.className = `schema-status ${className}`;
        }

        async function loadCountryNames() {
            try {
                const response = await fetch('https://restcountries.com/v3.1/all?fields=cca3,name');
                const countries = await response.json();
                countryNames = {};
                countries.forEach(country => {
                    countryNames[country.cca3] = country.name.common;
                });
            } catch (error) {
                console.warn('Could not load country names:', error);
            }
        }

        function handleSchemaFile(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        currentSchema = JSON.parse(e.target.result);
                        const isV21 = currentSchema.title && (currentSchema.title.includes('v3.0') || currentSchema.$id && currentSchema.$id.includes('0__2__1'));
                        const isV20 = currentSchema.title && (currentSchema.title.includes('v2.0') || currentSchema.$id && currentSchema.$id.includes('0__2__0'));
                        let statusMessage = '‚úì Custom schema loaded';
                        
                        if (isV21) {
                            statusMessage = '‚úì RDLS v3.0 schema loaded (enhanced with combobox fields)';
                        } else if (isV20) {
                            statusMessage = '‚úì RDLS v2.0 schema loaded';
                        }

                        // Load IMT definitions from custom schema
                        if (currentSchema.intensity_measure_definitions) {
                            IMT_DEFINITIONS = currentSchema.intensity_measure_definitions;
                            console.log('Loaded', Object.keys(IMT_DEFINITIONS).length, 'IMT definitions from custom schema');
                        }

                        // Load IMT mappings from custom schema (or use legacy if not available)
                        if (currentSchema.intensity_measure_mappings) {
                            HAZARD_IMT_MAPPING = {};
                            for (const [hazardType, imtCodes] of Object.entries(currentSchema.intensity_measure_mappings)) {
                                // Handle universal metrics separately
                                if (hazardType === 'universal') {
                                    UNIVERSAL_IMTS = imtCodes.map(code => {
                                        const def = IMT_DEFINITIONS[code];
                                        return {
                                            code: code,
                                            title: def ? def.title : code,
                                            description: def ? def.description : ''
                                        };
                                    });
                                } else {
                                    HAZARD_IMT_MAPPING[hazardType] = imtCodes.map(code => {
                                        const def = IMT_DEFINITIONS[code];
                                        return {
                                            code: code,
                                            title: def ? def.title : code,
                                            description: def ? def.description : ''
                                        };
                                    });
                                }
                            }
                            console.log('Loaded IMT mappings from custom schema');
                        }

                        // Reset form data when loading custom schema
                        currentFormData = {};
                        fieldValidationStatus.clear();

                        updateSchemaStatus(statusMessage, 'text-success');
                        generateForm();
                    } catch (error) {
                        console.error('Schema loading error:', error);
                        updateSchemaStatus('‚úó Invalid JSON file: ' + error.message, 'text-danger');
                    }
                };
                reader.readAsText(file);
            }
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('schemaDropZone');
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    document.getElementById('schemaFile').files = files;
                    handleSchemaFile({target: {files: files}});
                }
            });
        }

        function addSectionTab(section) {
            const tabsContainer = document.getElementById('metadataTabs');
            const contentContainer = document.getElementById('metadataTabContent');
            
            tabsContainer.style.display = 'flex';
            
            const tabButton = document.createElement('li');
            tabButton.className = 'nav-item';
            tabButton.setAttribute('role', 'presentation');
            tabButton.innerHTML = `
                <button class="nav-link ${section}-tab" id="${section}-tab" data-bs-toggle="tab" 
                        data-bs-target="#${section}" type="button" role="tab">
                    ${section.charAt(0).toUpperCase() + section.slice(1)}
                </button>
            `;
            tabsContainer.appendChild(tabButton);
            
            const tabContent = document.createElement('div');
            tabContent.className = 'tab-pane fade';
            tabContent.id = section;
            tabContent.setAttribute('role', 'tabpanel');
            tabContent.innerHTML = `<div id="${section}Form"></div>`;
            contentContainer.appendChild(tabContent);
        }

        function removeSectionTab(section) {
            const tabButton = document.getElementById(`${section}-tab`);
            const tabContent = document.getElementById(section);

            // Check if the tab being removed is currently active
            const isActive = tabButton && tabButton.classList.contains('active');

            if (tabButton) tabButton.parentElement.remove();
            if (tabContent) tabContent.remove();

            // If the removed tab was active, switch to the general tab
            if (isActive) {
                const generalTab = document.getElementById('general-tab');
                const generalContent = document.getElementById('general');
                if (generalTab && generalContent) {
                    // Activate the general tab
                    generalTab.classList.add('active');
                    generalContent.classList.add('show', 'active');
                }
            }

            if (activeSections.size === 1) {
                document.getElementById('metadataTabs').style.display = 'none';
            }
        }

        function generateForm() {
            if (!currentSchema) {
                updateFormStatus('warning', 'No schema loaded');
                return;
            }

            try {
                // Initialize array-type fields if they don't exist
                if (currentSchema.properties) {
                    Object.entries(currentSchema.properties).forEach(([key, property]) => {
                        if (property.type === 'array' && !currentFormData[key]) {
                            currentFormData[key] = [];
                        }
                    });
                }

                document.getElementById('metadataForm').innerHTML = '';
                SECTIONS.forEach(section => {
                    const sectionForm = document.getElementById(`${section}Form`);
                    if (sectionForm) sectionForm.innerHTML = '';
                });

                fieldValidationStatus.clear();

                generateSectionForm('general', currentSchema.properties, 'metadataForm');
                
                activeSections.forEach(section => {
                    if (section !== 'general' && currentSchema.properties[section]) {
                        const sectionSchema = currentSchema.properties[section];
                        if (sectionSchema.type === 'array') {
                            generateSectionForm(section, null, `${section}Form`);
                        } else {
                            generateSectionForm(section, sectionSchema.properties, `${section}Form`);
                        }
                    }
                });

                updateFormStatus('success', 'RDLS Form Ready');
                initializeDependentFields();
                updatePreview();
                updateValidationDisplay();

            } catch (error) {
                updateFormStatus('danger', 'Generation Error: ' + error.message);
                console.error('Form generation error:', error);
            }
        }

        function initializeDependentFields() {
            // Initialize license_url field visibility based on license value
            const licenseField = document.getElementById('license');
            const licenseUrlField = document.getElementById('license_url');

            if (licenseField && licenseUrlField) {
                const container = licenseUrlField.closest('.form-field, .modal-form-field');
                if (container) {
                    // Hide license_url by default unless license is "Custom"
                    if (licenseField.value !== 'Custom') {
                        container.style.display = 'none';
                        licenseUrlField.disabled = true;
                        licenseUrlField.required = false;
                        licenseUrlField.classList.remove('required');
                    } else {
                        container.style.display = 'block';
                        licenseUrlField.disabled = false;
                        licenseUrlField.required = true;
                        licenseUrlField.classList.add('required');
                    }
                }
            }
        }

        function generateSectionForm(sectionName, properties, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const form = document.createElement('form');
            form.className = 'needs-validation';
            form.noValidate = true;
            
            form.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const inputs = form.querySelectorAll('input, select, textarea');
                    const currentIndex = Array.from(inputs).indexOf(event.target);
                    if (currentIndex < inputs.length - 1) {
                        inputs[currentIndex + 1].focus();
                    }
                }
            });

            const title = document.createElement('h5');
            title.textContent = `${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)} Metadata`;
            title.className = 'mb-3 mt-3';
            form.appendChild(title);

            // Create unified context for normal form fields
            const context = new FieldCreationContext('normal', form);

            if (sectionName === 'general') {
                const requiredRoles = ['publisher', 'creator', 'contact_point'];

                // First, add all non-attribution fields
                Object.entries(properties).forEach(([key, property]) => {
                    if (!SECTIONS.includes(key) && key !== 'links' && key !== 'risk_data_type' && key !== 'attributions') {
                        const existingValue = currentFormData[key];
                        const fieldElement = context.createField(key, property, existingValue);
                        form.appendChild(fieldElement);
                    }
                });

                // Create Attribution section
                const attributionSection = document.createElement('div');
                attributionSection.className = 'card mb-4';

                const attributionHeader = document.createElement('div');
                attributionHeader.className = 'card-header';
                attributionHeader.innerHTML = '<h6 class="mb-0">Attribution</h6>';

                const attributionBody = document.createElement('div');
                attributionBody.className = 'card-body';

                // Initialize attributions array if it doesn't exist
                if (!currentFormData.attributions) {
                    currentFormData.attributions = [];
                }

                // Function to render attribution list
                const renderAttributionList = () => {
                    // Clear existing content
                    attributionBody.innerHTML = '';

                    const currentAttributions = currentFormData.attributions || [];

                    // Get mandatory attributions
                    const mandatoryAttributions = currentAttributions.filter(attr =>
                        requiredRoles.includes(attr.role)
                    );

                    // Get additional attributions
                    const additionalAttributions = currentAttributions.filter(attr =>
                        !requiredRoles.includes(attr.role)
                    );

                    // Show mandatory attributions as inline summaries
                    requiredRoles.forEach(role => {
                        const existingAttr = mandatoryAttributions.find(attr => attr.role === role);

                        const attrDiv = document.createElement('div');
                        attrDiv.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';

                        if (existingAttr) {
                            attrDiv.innerHTML = `
                                <div>
                                    <strong>${role.replace('_', ' ').toUpperCase()}</strong><br>
                                    <small class="text-muted">${existingAttr.entity?.name || 'Unnamed entity'}</small>
                                </div>
                                <div>
                                    <button type="button" class="btn btn-sm btn-outline-primary me-1" onclick="editAttribution('${existingAttr.id}')">Edit</button>
                                    <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteAttribution('${existingAttr.id}')">Delete</button>
                                </div>
                            `;
                        } else {
                            attrDiv.innerHTML = `
                                <div>
                                    <strong>${role.replace('_', ' ').toUpperCase()}</strong><br>
                                    <small class="text-danger">Required - Not set</small>
                                </div>
                                <div>
                                    <button type="button" class="btn btn-sm btn-primary" onclick="addRequiredAttribution('${role}')">Add</button>
                                </div>
                            `;
                        }

                        attributionBody.appendChild(attrDiv);
                    });

                    // Show additional attributions
                    additionalAttributions.forEach(attr => {
                        const attrDiv = document.createElement('div');
                        attrDiv.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded bg-light';
                        attrDiv.innerHTML = `
                            <div>
                                <strong>${attr.role.replace('_', ' ').toUpperCase()}</strong><br>
                                <small class="text-muted">${attr.entity?.name || 'Unnamed entity'}</small>
                            </div>
                            <div>
                                <button type="button" class="btn btn-sm btn-outline-primary me-1" onclick="editAttribution('${attr.id}')">Edit</button>
                                <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteAttribution('${attr.id}')">Delete</button>
                            </div>
                        `;
                        attributionBody.appendChild(attrDiv);
                    });

                    // Add "Add More Attribution" button
                    const addButton = document.createElement('button');
                    addButton.type = 'button';
                    addButton.className = 'btn btn-outline-secondary mt-3';
                    addButton.innerHTML = '+ Add More Attribution';
                    addButton.addEventListener('click', function() {
                        addNewAttribution();
                    });
                    attributionBody.appendChild(addButton);
                };

                // Global functions for attribution management
                window.editAttribution = (attrId) => {
                    const attribution = currentFormData.attributions.find(attr => attr.id === attrId);
                    if (attribution) {
                        const index = currentFormData.attributions.indexOf(attribution);
                        openObjectEditor('attributions', index, properties.attributions.items, currentFormData.attributions, renderAttributionList);
                    }
                };

                window.deleteAttribution = (attrId) => {
                    if (confirm('Are you sure you want to delete this attribution?')) {
                        currentFormData.attributions = currentFormData.attributions.filter(attr => attr.id !== attrId);
                        renderAttributionList();
                    }
                };

                window.addRequiredAttribution = (role) => {
                    const newId = `attribution_${role}_${Date.now()}`;
                    const newAttribution = {
                        id: newId,
                        role: role,
                        entity: {}
                    };
                    currentFormData.attributions.push(newAttribution);
                    const index = currentFormData.attributions.length - 1;
                    openObjectEditor('attributions', index, properties.attributions.items, currentFormData.attributions, renderAttributionList);
                };

                window.addNewAttribution = () => {
                    const newId = `attribution_${Date.now()}`;
                    const newAttribution = {
                        id: newId,
                        role: '',
                        entity: {}
                    };
                    currentFormData.attributions.push(newAttribution);
                    const index = currentFormData.attributions.length - 1;
                    openObjectEditor('attributions', index, properties.attributions.items, currentFormData.attributions, renderAttributionList);
                };

                // Initial render
                renderAttributionList();

                attributionSection.appendChild(attributionHeader);
                attributionSection.appendChild(attributionBody);
                form.appendChild(attributionSection);
            } else {
                // Check if this section is an array type (like the new exposure structure)
                const sectionSchema = currentSchema.properties[sectionName];
                if (sectionSchema && sectionSchema.type === 'array') {
                    // Handle array-type sections (like exposure)
                    const existingValue = currentFormData[sectionName];
                    const fieldElement = context.createField(sectionName, sectionSchema, existingValue);
                    form.appendChild(fieldElement);
                } else if (properties) {
                    // Handle object-type sections (like vulnerability, loss, hazard)
                    Object.entries(properties).forEach(([key, property]) => {
                        const existingValue = currentFormData[sectionName] && currentFormData[sectionName][key];
                        const fieldElement = context.createField(`${sectionName}.${key}`, property, existingValue);
                        form.appendChild(fieldElement);

                        // DIRECT FIX: Add currency field immediately after quantity_kind
                        if (key === 'quantity_kind') {
                            console.log(`Adding currency field after quantity_kind in ${sectionName}`);
                            const currencyProperty = {
                                "type": "string",
                                "enum": ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "CNY", "SEK", "NOK", "DKK", "PLN", "CZK", "HUF", "RON", "BGN", "HRK"],
                                "title": "Currency"
                            };
                            const currencyValue = currentFormData[sectionName] && currentFormData[sectionName]['currency'];
                            const currencyElement = context.createField(`${sectionName}.currency`, currencyProperty, currencyValue);

                            // Disable currency field by default
                            const currencyInput = currencyElement.querySelector('select, input');
                            if (currencyInput) {
                                currencyInput.disabled = true;
                                console.log(`Currency field disabled by default in ${sectionName}`);
                            }

                            // Currency field will be handled by the unified dependency system

                            form.appendChild(currencyElement);
                        }
                    });
                }
            }

            container.appendChild(form);
        }

        function resolveReference(ref) {
            if (!ref.startsWith('#/$defs/')) return null;
            if (!currentSchema || !currentSchema.$defs) {
                console.warn('Schema not loaded yet, cannot resolve ref:', ref);
                return null;
            }

            const path = ref.replace('#/$defs/', '').split('/');
            let current = currentSchema.$defs;

            for (const segment of path) {
                if (current && current[segment] !== undefined) {
                    current = current[segment];
                } else {
                    return null;
                }
            }

            return current;
        }

        function parseMarkdownLinks(text) {
            if (!text) return text;
            
            const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
            
            return text.replace(markdownLinkRegex, function(match, linkText, url) {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="text-primary text-decoration-none">${linkText} <small>‚Üó</small></a>`;
            });
        }

        function getNestedValue(obj, path) {
            const keys = path.split('.');
            let current = obj;
            
            for (const key of keys) {
                if (current && current[key] !== undefined) {
                    current = current[key];
                } else {
                    return null;
                }
            }
            
            return current;
        }

        function setNestedValue(obj, path, value) {
            const keys = path.split('.');
            let current = obj;
            
            for (let i = 0; i < keys.length - 1; i++) {
                if (!current[keys[i]]) current[keys[i]] = {};
                current = current[keys[i]];
            }
            
            current[keys[keys.length - 1]] = value;
        }

        function openObjectEditor(arrayName, objectIndex, objectSchema, arrayData, renderCallback) {
            // Ensure schema is loaded before opening the modal
            if (!currentSchema) {
                console.warn('Schema not loaded yet, cannot open object editor for:', arrayName);
                alert('Please wait for the schema to load before opening the editor.');
                return;
            }

            if (objectSchema.$ref) {
            objectSchema = resolveReference(objectSchema.$ref);
            }

            currentObjectEditor = {
            arrayName: arrayName,
            objectIndex: objectIndex,
            objectSchema: objectSchema,
            arrayData: arrayData,
            renderCallback: renderCallback
            };

            const modalTitle = document.getElementById('objectEditorModalLabel');
            modalTitle.textContent = `Edit ${objectSchema.title || arrayName}`;

            // Always use the latest array data from currentFormData if available
            const fullArrayData = getNestedValue(currentFormData, arrayName) || [];
            // Preload the object data from the array if it exists
            // Only clone the object if editing, otherwise use empty object for new
            let objectData = {};
            if (typeof objectIndex === 'number' && fullArrayData[objectIndex]) {
            objectData = { ...fullArrayData[objectIndex] };
            }


            const fieldsContainer = document.getElementById('objectEditorFields');
            fieldsContainer.innerHTML = '';

            // Create unified context for modal fields
            const modalContext = new FieldCreationContext('modal', fieldsContainer);

            if (objectSchema.properties) {
            Object.entries(objectSchema.properties).forEach(([key, property]) => {
                // If this property is an array, allow editing its items inline
                if (property.type === 'array') {
                // Use the array from objectData if present, ensuring we maintain existing data
                let arrayValue = objectData[key];
                if (!Array.isArray(arrayValue)) {
                    arrayValue = [];
                    // Initialize the array in objectData so changes are tracked
                    objectData[key] = arrayValue;
                }
                const arrayField = modalContext.createField(key, property, arrayValue);
                fieldsContainer.appendChild(arrayField);
                } else {
                // For non-array properties, use the existing value from objectData
                const fieldElement = modalContext.createField(key, property, objectData[key]);
                fieldsContainer.appendChild(fieldElement);

                // Add currency field immediately after quantity_kind in modals
                if (key === 'quantity_kind') {
                    const currencyProperty = {
                        "type": "string",
                        "enum": ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "CNY", "SEK", "NOK", "DKK", "PLN", "CZK", "HUF", "RON", "BGN", "HRK"],
                        "title": "Currency"
                    };
                    const savedCurrencyValue = objectData['currency'];
                    const currencyElement = modalContext.createField('currency', currencyProperty, savedCurrencyValue);
                    fieldsContainer.appendChild(currencyElement);

                    // Ensure currency value is properly set after field creation
                    if (savedCurrencyValue) {
                        setTimeout(() => {
                            const currencyInput = currencyElement.querySelector('select, input');
                            if (currencyInput && currencyInput.value !== savedCurrencyValue) {
                                currencyInput.value = savedCurrencyValue;
                            }
                        }, 100);
                    }

                    // Currency field will be handled by the unified dependency system
                }
                }
            });
            }

            // Universal currency field restoration for nested structures (like loss.impact_and_losses.currency)
            setTimeout(() => {
                const allCurrencyFields = fieldsContainer.querySelectorAll('select[id*="currency"], input[id*="currency"]');

                allCurrencyFields.forEach(currencyField => {
                    const fieldId = currencyField.id;
                    const fieldName = fieldId.replace('modal_', '');
                    const savedValue = getNestedValue(objectData, fieldName);

                    if (savedValue && currencyField.value !== savedValue) {
                        currencyField.value = savedValue;
                    }
                });
            }, 150);

            const form = document.getElementById('objectEditorForm');
                        form.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const inputs = form.querySelectorAll('input, select, textarea');
                const currentIndex = Array.from(inputs).indexOf(event.target);
                if (currentIndex < inputs.length - 1) {
                inputs[currentIndex + 1].focus();
                } else {
                document.getElementById('saveObjectBtn').click();
                }
            }
            });

            const modal = new bootstrap.Modal(document.getElementById('objectEditorModal'));
            modal.show();
        }

        function createObjectSummaryCard(objectData, index, arrayName, arrayProperty) {
            const card = document.createElement('div');
            card.className = 'object-summary-card';
            
            let objectSchema = arrayProperty.items;
            if (objectSchema.$ref) {
                objectSchema = resolveReference(objectSchema.$ref);
            }
            
            const title = document.createElement('div');
            title.className = 'object-summary-title';
            
            let summaryText = `${arrayProperty.title || arrayName} ${index + 1}`;
            if (objectData) {
                if ((arrayName.includes('metric') || arrayName.includes('cost')) && objectData.dimension) {
                    summaryText = `${objectData.dimension.charAt(0).toUpperCase() + objectData.dimension.slice(1)} ${arrayProperty.title || arrayName}`;
                } else if (arrayName.includes('exposure') && objectData.category) {
                    summaryText = `${objectData.category.charAt(0).toUpperCase() + objectData.category.slice(1)} Exposure`;              
                } else if (arrayName.includes('event_sets') && objectData.hazards && objectData.hazards.length > 0) {
                    const hazard = objectData.hazards[0];
                    let hazardDisplay = hazard.type ? hazard.type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Hazard';
                    if (hazard.processes && hazard.processes.length > 0) {
                        const process = hazard.processes[0].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        hazardDisplay += ` / ${process}`;
                    }
                    summaryText = hazardDisplay;
                } else if (arrayName.includes('losses') && objectData.hazard_type) {
                    summaryText = objectData.hazard_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) + ' Loss';
                } else if (objectData.name) {
                    summaryText = objectData.name;
                } else if (objectData.title) {
                    summaryText = objectData.title;
                } else if (objectData.id) {
                    summaryText = objectData.id;
                }
            }
            title.textContent = summaryText;
            
            const details = document.createElement('div');
            details.className = 'object-summary-details';
            
            if (objectData) {
                let keyFields = [];
                
                if (arrayName.includes('exposure')) {
                    if (objectData.taxonomy) {
                        keyFields.push(`taxonomy: ${objectData.taxonomy}`);
                    }
                    if (objectData.metrics && objectData.metrics.length > 0) {
                        const metricCount = objectData.metrics.length;
                        keyFields.push(`metrics: ${metricCount} metric${metricCount !== 1 ? 's' : ''}`);
                    }
                }
                
                if (arrayName.includes('metric') && objectData.quantity_kind) {
                    keyFields.push(`quantity: ${objectData.quantity_kind}`);
                }
                
                if (arrayName.includes('cost') && objectData.unit) {
                    keyFields.push(`unit: ${objectData.unit}`);
                }
                
                if (arrayName.includes('event_sets')) {
                    if (objectData.analysis_type) {
                        keyFields.push(`analysis: ${objectData.analysis_type}`);
                    }
                    if (objectData.event_count) {
                        keyFields.push(`events: ${objectData.event_count}`);
                    }
                    if (objectData.occurrence_range) {
                        keyFields.push(`range: ${objectData.occurrence_range}`);
                    }
                }
                
                if (arrayName.includes('losses')) {
                    if (objectData.hazard_process) {
                        keyFields.push(`process: ${objectData.hazard_process.replace(/_/g, ' ')}`);
                    }
                    if (objectData.category) {
                        keyFields.push(`category: ${objectData.category}`);
                    }
                    if (objectData.type) {
                        keyFields.push(`type: ${objectData.type}`);
                    }
                }
                
                const otherFields = ['description', 'format', 'role', 'url'].filter(field => 
                    objectData[field] && !keyFields.some(kf => kf.includes(field))
                );
                keyFields = keyFields.concat(otherFields.map(field => `${field}: ${objectData[field]}`));
                
                if (keyFields.length > 0) {
                    details.textContent = keyFields.join(' ‚Ä¢ ');
                } else {
                    details.textContent = 'Click Edit to add details';
                }
            } else {
                details.textContent = 'New object - click Edit to configure';
            }
            
            const actions = document.createElement('div');
            actions.className = 'd-flex gap-2 mt-2';
            
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'btn btn-outline-primary btn-sm';
            editBtn.textContent = '‚úèÔ∏è Edit';
            editBtn.addEventListener('click', () => {
                openObjectEditor(arrayName, index, arrayProperty.items, null, null);
            });
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'btn btn-outline-danger btn-sm';
            removeBtn.textContent = 'üóëÔ∏è Remove';
            removeBtn.addEventListener('click', () => {
                if (confirm(`Remove this ${arrayProperty.title || arrayName}?`)) {
                    const fullArrayData = getNestedValue(currentFormData, arrayName) || [];
                    fullArrayData.splice(index, 1);
                    setNestedValue(currentFormData, arrayName, fullArrayData);
                    updateFormData();
                    generateForm();
                }
            });
            
            actions.appendChild(editBtn);
            actions.appendChild(removeBtn);
            
            card.appendChild(title);
            card.appendChild(details);
            card.appendChild(actions);
            
            return card;
        }

        function saveCurrentObject() {
            const form = document.getElementById('objectEditorForm');
            const formData = new FormData(form);
            
            // Start with the existing object data to preserve arrays that were modified
            let objectData = {};
            
            // First, get any existing object data to preserve arrays
            const fullArrayData = getNestedValue(currentFormData, currentObjectEditor.arrayName) || [];
            if (typeof currentObjectEditor.objectIndex === 'number' && fullArrayData[currentObjectEditor.objectIndex]) {
                // Copy existing object data, including any arrays that were modified in the modal
                objectData = JSON.parse(JSON.stringify(fullArrayData[currentObjectEditor.objectIndex]));
            }
            
            // Now we need to get the current state of any array fields that were edited in the modal
            // Find all array containers in the modal and extract their current data
            const arrayContainers = document.querySelectorAll('#objectEditorFields .array-field');
            arrayContainers.forEach(container => {
                const containerId = container.querySelector('[id$="_items"]')?.id;
                if (containerId) {
                    const fieldName = containerId.replace('modal_', '').replace('_items', '');
                    const cards = container.querySelectorAll('.card[data-item-index]');
                    const arrayData = [];
                    
                    cards.forEach((card, index) => {
                        const item = {};
                        const fieldDivs = card.querySelectorAll('[data-field-name]');
                        
                        fieldDivs.forEach(fieldDiv => {
                            const fieldNameAttr = fieldDiv.getAttribute('data-field-name');
                            if (fieldNameAttr && fieldNameAttr !== 'id') {
                                const input = fieldDiv.querySelector('input, select, textarea');
                                if (input) {
                                    if (input.type === 'checkbox') {
                                        item[fieldNameAttr] = input.checked;
                                    } else {
                                        item[fieldNameAttr] = input.value;
                                    }
                                }
                            }
                        });
                        
                        // Handle bbox and centroid fields specially - they have names like fieldName_0, fieldName_1, etc.
                        const coordInputs = card.querySelectorAll('input[name$="_0"], input[name$="_1"], input[name$="_2"], input[name$="_3"]');
                        const coordGroups = {};
                        coordInputs.forEach(input => {
                            const match = input.name.match(/(.+)_(\d+)$/);
                            if (match) {
                                const fieldName = match[1].replace('modal_', '');
                                const index = parseInt(match[2]);
                                if (!coordGroups[fieldName]) coordGroups[fieldName] = [];
                                coordGroups[fieldName][index] = parseFloat(input.value) || 0;
                            }
                        });

                        // Add bbox/centroid arrays to the item
                        Object.entries(coordGroups).forEach(([fieldName, values]) => {
                            item[fieldName] = values;
                        });
                        
                        // Preserve the ID if it exists
                        if (objectData[fieldName] && objectData[fieldName][index] && objectData[fieldName][index].id) {
                            item.id = objectData[fieldName][index].id;
                        } else {
                            // Generate a new ID if needed
                            let idPrefix = 'item';
                            if (fieldName === 'metrics') idPrefix = 'metric';
                            else if (fieldName === 'cost') idPrefix = 'cost';
                            else if (fieldName === 'hazards') idPrefix = 'hazard';
                            item.id = generateUniqueId(idPrefix);
                        }
                        
                        arrayData.push(item);
                    });
                    
                    // Update the object data with the current array state
                    objectData[fieldName] = arrayData;
                }
            });
            
            // Collect regular form data (this will override any simple field values)
            for (let [key, value] of formData.entries()) {
                const fieldName = key.replace('modal_', '');
                
                if (fieldName.includes('.')) {
                    setNestedValue(objectData, fieldName, value);
                } else {
                    // Don't override array fields that we just processed above
                    const isArrayField = document.querySelector(`#objectEditorFields .array-field [id="modal_${fieldName}_items"]`);
                    if (!isArrayField) {
                        objectData[fieldName] = value;
                    }
                }
            }
            
            // Collect checkbox data
            const checkboxes = form.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const fieldName = cb.name.replace('modal_', '');
                if (fieldName.includes('.')) {
                    setNestedValue(objectData, fieldName, cb.checked);
                } else {
                    // Don't override array fields that we just processed above
                    const isArrayField = document.querySelector(`#objectEditorFields .array-field [id="modal_${fieldName}_items"]`);
                    if (!isArrayField) {
                        objectData[fieldName] = cb.checked;
                    }
                }
            });
            
            // Handle bbox and centroid fields in the main form (not inside array containers)
            const coordInputs = form.querySelectorAll('input[name$="_0"], input[name$="_1"], input[name$="_2"], input[name$="_3"]');
            const coordGroups = {};
            coordInputs.forEach(input => {
                // Skip if this coordinate input is inside an array container (already handled above)
                const isInArrayContainer = input.closest('.array-field');
                if (!isInArrayContainer) {
                    const match = input.name.match(/(.+)_(\d+)$/);
                    if (match) {
                        const fieldName = match[1].replace('modal_', '');
                        const index = parseInt(match[2]);
                        if (!coordGroups[fieldName]) coordGroups[fieldName] = [];
                        coordGroups[fieldName][index] = parseFloat(input.value) || 0;
                    }
                }
            });

            // Add bbox/centroid arrays to the object data
            Object.entries(coordGroups).forEach(([fieldName, values]) => {
                if (fieldName.includes('.')) {
                    setNestedValue(objectData, fieldName, values);
                } else {
                    objectData[fieldName] = values;
                }
            });
            
            // Get the full array data and update/add the object
            let fullArrayDataUpdated = getNestedValue(currentFormData, currentObjectEditor.arrayName);
            if (!fullArrayDataUpdated) {
                fullArrayDataUpdated = [];
                setNestedValue(currentFormData, currentObjectEditor.arrayName, fullArrayDataUpdated);
            }
            
            // Ensure the object has an ID
            if (currentObjectEditor.objectIndex >= fullArrayDataUpdated.length) {
                let idPrefix = 'item';
                if (currentObjectEditor.arrayName === 'resources') idPrefix = 'resource';
                else if (currentObjectEditor.arrayName === 'sources') idPrefix = 'source';
                else if (currentObjectEditor.arrayName === 'attributions') idPrefix = 'attribution';
                else if (currentObjectEditor.arrayName === 'referenced_by') idPrefix = 'reference';
                else if (currentObjectEditor.arrayName.includes('event_sets')) idPrefix = 'event_set';
                else if (currentObjectEditor.arrayName.includes('losses')) idPrefix = 'loss';
                
                objectData.id = generateUniqueId(idPrefix);
            } else {
                const existingObject = fullArrayDataUpdated[currentObjectEditor.objectIndex];
                if (existingObject && existingObject.id) {
                    objectData.id = existingObject.id;
                } else {
                    let idPrefix = 'item';
                    if (currentObjectEditor.arrayName === 'resources') idPrefix = 'resource';
                    else if (currentObjectEditor.arrayName === 'sources') idPrefix = 'source';
                    else if (currentObjectEditor.arrayName === 'attributions') idPrefix = 'attribution';
                    else if (currentObjectEditor.arrayName === 'referenced_by') idPrefix = 'reference';
                    else if (currentObjectEditor.arrayName.includes('event_sets')) idPrefix = 'event_set';
                    else if (currentObjectEditor.arrayName.includes('losses')) idPrefix = 'loss';
                    
                    objectData.id = generateUniqueId(idPrefix);
                }
            }
            
            // Update the array
            if (currentObjectEditor.objectIndex >= fullArrayDataUpdated.length) {
                fullArrayDataUpdated.push(objectData);
            } else {
                fullArrayDataUpdated[currentObjectEditor.objectIndex] = objectData;
            }
            
            setNestedValue(currentFormData, currentObjectEditor.arrayName, fullArrayDataUpdated);
            updatePreview();
            generateForm();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('objectEditorModal'));
            modal.hide();
            
            updateFormStatus('success', 'Object saved successfully');
        }

        function updateValidationDisplay() {
            const totalFields = fieldValidationStatus.size;
            const validFields = Array.from(fieldValidationStatus.values()).filter(status => status.isValid).length;

            const progressBar = document.getElementById('validationProgress');
            const progressPercent = totalFields > 0 ? (validFields / totalFields) * 100 : 0;
            progressBar.style.width = `${progressPercent}%`;

            document.getElementById('validFieldCount').textContent = validFields;
            document.getElementById('totalFieldCount').textContent = totalFields;

            const overallStatus = document.getElementById('overallValidation');
            const publishButton = document.getElementById('publishGitHub');

            if (totalFields === 0) {
                overallStatus.className = 'badge bg-secondary';
                overallStatus.textContent = 'Not validated';
                publishButton.disabled = true;
                publishButton.className = 'btn btn-warning btn-sm w-100 mb-2';
                publishButton.title = 'Run validation first to enable publishing';
            } else if (validFields === totalFields) {
                overallStatus.className = 'badge bg-success';
                overallStatus.textContent = 'All valid';
                publishButton.disabled = false;
                publishButton.className = 'btn btn-success btn-sm w-100 mb-2';
                publishButton.title = 'Publish validated dataset to GitHub';
            } else {
                overallStatus.className = 'badge bg-warning';
                overallStatus.textContent = `${validFields}/${totalFields} valid`;
                publishButton.disabled = true;
                publishButton.className = 'btn btn-warning btn-sm w-100 mb-2';
                publishButton.title = `Fix ${totalFields - validFields} validation error(s) to enable publishing`;
            }
        }

        function updateFormData() {
            const allForms = document.querySelectorAll('#metadataTabContent form');
            const newFormData = {};
            
            allForms.forEach(form => {
                const formData = new FormData(form);
                
                for (let [key, value] of formData.entries()) {
                    if (!key.includes('_0') && !key.includes('_1') && !key.includes('_2') && !key.includes('_3')) {
                        setNestedValue(newFormData, key, value);
                    }
                }
                
                const checkboxes = form.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    setNestedValue(newFormData, cb.name, cb.checked);
                });
                
                const coordFields = form.querySelectorAll('input[name*="_0"], input[name*="_1"], input[name*="_2"], input[name*="_3"]');
                const coordGroups = {};
                coordFields.forEach(input => {
                    const match = input.name.match(/(.+)_(\d+)$/);
                    if (match) {
                        const fieldName = match[1];
                        const index = parseInt(match[2]);
                        if (!coordGroups[fieldName]) coordGroups[fieldName] = [];
                        coordGroups[fieldName][index] = parseFloat(input.value) || 0;
                    }
                });

                Object.entries(coordGroups).forEach(([fieldName, values]) => {
                    setNestedValue(newFormData, fieldName, values);
                });
            });
            
            // Preserve existing array-type fields that shouldn't be overwritten by form data
            const arrayFields = ['resources', 'sources', 'attributions', 'referenced_by', 'exposure'];
            arrayFields.forEach(fieldName => {
                if (currentFormData[fieldName] && Array.isArray(currentFormData[fieldName])) {
                    newFormData[fieldName] = currentFormData[fieldName];
                }
            });

            // Preserve spatial.countries array if it exists
            if (currentFormData.spatial?.countries && Array.isArray(currentFormData.spatial.countries)) {
                if (!newFormData.spatial) newFormData.spatial = {};
                newFormData.spatial.countries = currentFormData.spatial.countries;
            }
            
            // Merge form data, but preserve array structure for known array fields
            Object.keys(newFormData).forEach(key => {
                if (currentSchema && currentSchema.properties && currentSchema.properties[key]) {
                    const fieldSchema = currentSchema.properties[key];
                    if (fieldSchema.type === 'array') {
                        if (Array.isArray(newFormData[key]) || !currentFormData[key]) {
                            currentFormData[key] = newFormData[key];
                        } else if (!Array.isArray(newFormData[key]) && Array.isArray(currentFormData[key])) {
                            console.warn(`Ignoring non-array value for array field ${key}:`, typeof newFormData[key], newFormData[key]);
                        }
                    } else if (fieldSchema.type === 'object' && key === 'spatial') {
                        // Special handling for spatial object to preserve nested arrays
                        if (!currentFormData[key]) currentFormData[key] = {};
                        // Merge spatial properties but preserve the countries array
                        Object.keys(newFormData[key] || {}).forEach(spatialKey => {
                            if (spatialKey !== 'countries') {
                                currentFormData[key][spatialKey] = newFormData[key][spatialKey];
                            }
                        });
                        // Keep the countries array from preservation above
                    } else {
                        currentFormData[key] = newFormData[key];
                    }
                } else {
                    currentFormData[key] = newFormData[key];
                }
            });
            
            updatePreview();
            autoSave();

            // Trigger dataset-level validation to keep publish button state updated
            validateDatasetRequirements();
            updateValidationDisplay();
        }

        function getFilteredFormData() {
            // Get the current schema version
            const version = document.getElementById('schemaVersionSelect').value;

            // Map version to schema URL format
            const versionMap = {
                '0.2': '0__2__0',
                '0.3': '0__3__0'
            };

            const schemaVersion = versionMap[version] || '0__3__0';
            const schemaUrl = `https://docs.riskdatalibrary.org/en/${schemaVersion}/rdls_schema.json`;

            // Define the correct order based on RDLS schema
            const schemaFieldOrder = [
                'id', 'title', 'description', 'risk_data_type', 'version', 'purpose',
                'project', 'details', 'spatial', 'license',
                'attributions', 'sources', 'referenced_by', 'resources',
                'hazard', 'exposure', 'vulnerability', 'loss', 'links'
            ];

            // Create filtered data with ordered fields
            const filteredData = {};

            // Add fields in schema order
            schemaFieldOrder.forEach(key => {
                if (currentFormData[key] !== undefined) {
                    // For section fields, only include if active
                    if (SECTIONS.includes(key)) {
                        if (activeSections.has(key)) {
                            filteredData[key] = currentFormData[key];
                        }
                    } else {
                        // Always include non-section fields
                        filteredData[key] = currentFormData[key];
                    }
                }
            });

            // Add any remaining fields not in the schema order (for extensibility)
            Object.entries(currentFormData).forEach(([key, value]) => {
                if (!schemaFieldOrder.includes(key) && !SECTIONS.includes(key)) {
                    filteredData[key] = value;
                }
            });

            return filteredData;
        }

        function updatePreview() {
            const filteredData = getFilteredFormData();

            // Get the current schema version
            const version = document.getElementById('schemaVersionSelect').value;
            const versionMap = {
                '0.2': '0__2__0',
                '0.3': '0__3__0'
            };
            const schemaVersion = versionMap[version] || '0__3__0';
            const schemaUrl = `https://docs.riskdatalibrary.org/en/${schemaVersion}/rdls_schema.json`;

            // Ensure links array exists and has the schema reference
            if (!filteredData.links) {
                filteredData.links = [];
            }

            // Check if describedby link already exists
            const hasDescribedBy = filteredData.links.some(link => link.rel === 'describedby');

            if (!hasDescribedBy) {
                // Add schema reference as first link with rel="describedby"
                filteredData.links.unshift({
                    href: schemaUrl,
                    rel: 'describedby'
                });
            } else {
                // Update existing describedby link to current schema version
                const describedByIndex = filteredData.links.findIndex(link => link.rel === 'describedby');
                filteredData.links[describedByIndex].href = schemaUrl;
            }

            // Show preview as a complete package (matching export format)
            const previewData = {
                datasets: [filteredData]
            };

            document.getElementById('outputPreview').textContent = JSON.stringify(previewData, null, 2);
        }

        function updateFormStatus(type, message) {
            const status = document.getElementById('formStatus');
            status.className = `badge bg-${type}`;
            status.textContent = message;
        }

        function updateRiskDataType() {
            // Automatically set risk_data_type based on checked sections
            const riskDataTypes = [];

            SECTIONS.forEach(section => {
                const checkbox = document.getElementById(`${section}Check`);
                if (checkbox && checkbox.checked) {
                    riskDataTypes.push(section);
                }
            });

            // Always ensure risk_data_type is an array and update currentFormData
            currentFormData.risk_data_type = riskDataTypes;
        }

        function validateForm() {
            updateFormData();

            // First, validate individual field inputs
            const allInputs = document.querySelectorAll('#metadataTabContent input, #metadataTabContent select, #metadataTabContent textarea');
            allInputs.forEach(input => {
                if (input.name) {
                    const property = getPropertyFromSchema(input.name);
                    if (property) {
                        const value = input.type === 'checkbox' ? input.checked : input.value;
                        const context = new FieldCreationContext('normal');
                        context.validateField(input.name, value, property);
                    }
                }
            });

            // Add complex dataset-level validations
            validateDatasetRequirements();

            const totalFields = fieldValidationStatus.size;
            const validFields = Array.from(fieldValidationStatus.values()).filter(status => status.isValid).length;

            if (validFields === totalFields && totalFields > 0) {
                updateFormStatus('success', 'RDLS Compliant ‚úì');
                alert('‚úÖ All fields are valid! Your metadata is RDLS compliant.');
            } else {
                const invalidFields = Array.from(fieldValidationStatus.entries())
                    .filter(([name, status]) => !status.isValid)
                    .map(([name, status]) => `${name}: ${status.errorMessage}`);
                updateFormStatus('warning', `${validFields}/${totalFields} valid`);
                alert(`‚ö†Ô∏è ${invalidFields.length} field(s) need attention:\n\n‚Ä¢ ${invalidFields.join('\n‚Ä¢ ')}`);
            }
        }

        function validateDatasetRequirements() {
            // 1. Validate at least one risk_data_type
            const riskDataTypes = currentFormData.risk_data_type || [];
            const riskDataTypeValid = riskDataTypes.length > 0 && !riskDataTypes.every(type => !type || type.trim() === '');

            if (!riskDataTypeValid) {
                fieldValidationStatus.set('dataset_risk_data_type', {
                    isValid: false,
                    errorMessage: 'Dataset must have at least one risk data type'
                });
            } else {
                fieldValidationStatus.set('dataset_risk_data_type', {
                    isValid: true,
                    errorMessage: ''
                });
            }


            // 2. Validate at least one resource with required fields
            const resources = currentFormData.resources || [];
            let resourcesValid = true;
            let resourceError = '';

            if (!resources.length) {
                resourcesValid = false;
                resourceError = 'Dataset must have at least one resource';
            } else {
                // Check each resource for required fields
                for (let i = 0; i < resources.length; i++) {
                    const resource = resources[i];
                    const resourceNum = i + 1;

                    if (!resource.title || resource.title.trim() === '') {
                        resourcesValid = false;
                        resourceError = `Resource ${resourceNum} is missing required title`;
                        break;
                    }
                    if (!resource.description || resource.description.trim() === '') {
                        resourcesValid = false;
                        resourceError = `Resource ${resourceNum} is missing required description`;
                        break;
                    }
                    if ((!resource.download_url || resource.download_url.trim() === '') &&
                        (!resource.access_url || resource.access_url.trim() === '')) {
                        resourcesValid = false;
                        resourceError = `Resource ${resourceNum} must have either download_url or access_url`;
                        break;
                    }
                }
            }

            fieldValidationStatus.set('dataset_resources', {
                isValid: resourcesValid,
                errorMessage: resourceError
            });


            // 3. Validate attribution entities
            const attributions = currentFormData.attributions || [];
            let attributionsValid = true;
            let attributionError = '';

            // First check if required roles are present
            const requiredRoles = ['publisher', 'creator', 'contact_point'];
            const presentRoles = attributions.map(a => a.role).filter(Boolean);

            for (const role of requiredRoles) {
                if (!presentRoles.includes(role)) {
                    attributionsValid = false;
                    attributionError = `Required attribution role missing: ${role.replace('_', ' ')}`;
                    break;
                }
            }

            // Then validate each attribution has required fields
            if (attributionsValid) {
                for (let i = 0; i < attributions.length; i++) {
                    const attribution = attributions[i];
                    const attrNum = i + 1;

                    // Check if entity exists and has required fields
                    if (!attribution.entity) {
                        attributionsValid = false;
                        attributionError = `Attribution ${attrNum} is missing entity information`;
                        break;
                    }
                    if (!attribution.entity.name || attribution.entity.name.trim() === '') {
                        attributionsValid = false;
                        attributionError = `Attribution ${attrNum} is missing required entity name`;
                        break;
                    }
                    if (!attribution.entity.email || attribution.entity.email.trim() === '') {
                        attributionsValid = false;
                        attributionError = `Attribution ${attrNum} is missing required entity email`;
                        break;
                    }
                }
            }

            fieldValidationStatus.set('dataset_attributions', {
                isValid: attributionsValid,
                errorMessage: attributionError
            });


            // 4. Validate exposure data (if exposure is in risk_data_type AND exposure section is active)
            const hasExposureType = riskDataTypes.some(type => type && type.toLowerCase().includes('exposure'));
            const exposureSectionActive = activeSections.has('exposure');
            let exposureValid = true;
            let exposureError = '';

            if (hasExposureType && exposureSectionActive) {
                const exposures = currentFormData.exposure || [];

                if (!exposures.length) {
                    exposureValid = false;
                    exposureError = 'Dataset with exposure risk_data_type must have at least one exposure item';
                } else {
                    // Check each exposure item
                    for (let i = 0; i < exposures.length; i++) {
                        const exposure = exposures[i];
                        const expNum = i + 1;

                        // Check for required category
                        if (!exposure.category || exposure.category.trim() === '') {
                            exposureValid = false;
                            exposureError = `Exposure ${expNum} is missing required category`;
                            break;
                        }

                        // Check for at least one metric
                        const metrics = exposure.metrics || [];
                        if (!metrics.length) {
                            exposureValid = false;
                            exposureError = `Exposure ${expNum} must have at least one metric`;
                            break;
                        }

                        // Check each metric for required fields
                        for (let j = 0; j < metrics.length; j++) {
                            const metric = metrics[j];
                            const metricNum = j + 1;

                            if (!metric.dimension || metric.dimension.trim() === '') {
                                exposureValid = false;
                                exposureError = `Exposure ${expNum}, Metric ${metricNum} is missing required dimension`;
                                break;
                            }

                            if (!metric.quantity_kind || metric.quantity_kind.trim() === '') {
                                exposureValid = false;
                                exposureError = `Exposure ${expNum}, Metric ${metricNum} is missing required quantity_kind`;
                                break;
                            }
                        }

                        if (!exposureValid) break;
                    }
                }
            }

            fieldValidationStatus.set('dataset_exposure', {
                isValid: exposureValid,
                errorMessage: exposureError
            });


            // 5. Validate loss data (if loss is in risk_data_type AND loss section is active)
            const hasLossType = riskDataTypes.some(type => type && type.toLowerCase().includes('loss'));
            const lossSectionActive = activeSections.has('loss');
            let lossValid = true;
            let lossError = '';

            if (hasLossType && lossSectionActive) {
                const losses = (currentFormData.loss && currentFormData.loss.losses) || [];


                if (!losses.length) {
                    lossValid = false;
                    lossError = 'Dataset with loss risk_data_type must have at least one loss item';
                } else {
                    // Define required loss attributes with correct field paths
                    const requiredLossAttributes = [
                        { field: 'hazard_type', name: 'hazard type' },
                        { field: 'asset_category', name: 'asset category' },
                        { field: 'asset_dimension', name: 'asset dimension' },
                        { field: 'impact_and_losses.impact_type', name: 'impact type' },
                        { field: 'impact_and_losses.impact_modelling', name: 'impact modelling' },
                        { field: 'impact_and_losses.impact_metric', name: 'impact metric' },
                        { field: 'impact_and_losses.quantity_kind', name: 'quantity kind' },
                        { field: 'impact_and_losses.loss_type', name: 'loss type' },
                        { field: 'impact_and_losses.loss_approach', name: 'loss approach' },
                        { field: 'impact_and_losses.loss_frequency_type', name: 'loss frequency type' }
                    ];

                    // Check each loss item
                    for (let i = 0; i < losses.length; i++) {
                        const loss = losses[i];
                        const lossNum = i + 1;

                        // Check each required attribute
                        for (const attr of requiredLossAttributes) {
                            // Handle nested field paths (e.g., 'impact_and_losses.impact_type')
                            let fieldValue;
                            if (attr.field.includes('.')) {
                                const parts = attr.field.split('.');
                                fieldValue = loss[parts[0]] && loss[parts[0]][parts[1]];
                            } else {
                                fieldValue = loss[attr.field];
                            }

                            if (!fieldValue || fieldValue.toString().trim() === '') {
                                lossValid = false;
                                lossError = `Loss ${lossNum} is missing required ${attr.name}`;
                                break;
                            }
                        }

                        if (!lossValid) break;
                    }
                }
            }

            fieldValidationStatus.set('dataset_loss', {
                isValid: lossValid,
                errorMessage: lossError
            });

            // 6. Validate vulnerability data (if vulnerability is in risk_data_type AND vulnerability section is active)
            const hasVulnerabilityType = riskDataTypes.some(type => type && type.toLowerCase().includes('vulnerability'));
            const vulnerabilitySectionActive = activeSections.has('vulnerability');
            let vulnerabilityValid = true;
            let vulnerabilityError = '';

            if (hasVulnerabilityType && vulnerabilitySectionActive) {
                const vulnerability = currentFormData.vulnerability;

                if (!vulnerability) {
                    vulnerabilityValid = false;
                    vulnerabilityError = 'Dataset with vulnerability risk_data_type must have vulnerability metadata';
                } else {
                    // Define required vulnerability attributes
                    const requiredVulnerabilityAttributes = [
                        { field: 'hazard_primary', name: 'primary hazard type' },
                        { field: 'hazard_analysis_type', name: 'hazard analysis type' },
                        { field: 'intensity', name: 'hazard intensity measurement' },
                        { field: 'category', name: 'exposure category' },
                        { field: 'impact_type', name: 'impact type' },
                        { field: 'impact_modelling', name: 'impact modelling' },
                        { field: 'impact_metric', name: 'impact metric' },
                        { field: 'quantity_kind', name: 'quantity kind' }
                    ];

                    // Check each required attribute
                    for (const attr of requiredVulnerabilityAttributes) {
                        if (!vulnerability[attr.field] || vulnerability[attr.field].toString().trim() === '') {
                            vulnerabilityValid = false;
                            vulnerabilityError = `Vulnerability is missing required ${attr.name}`;
                            break;
                        }
                    }

                    // Check that at least one vulnerability approach is present
                    if (vulnerabilityValid) {
                        const hasVulnerabilityApproach =
                            (vulnerability.functions?.vulnerability) ||
                            (vulnerability.functions?.fragility) ||
                            (vulnerability.functions?.damage_to_loss) ||
                            (vulnerability.functions?.engineering_demand) ||
                            (vulnerability.se_indicator);

                        if (!hasVulnerabilityApproach) {
                            vulnerabilityValid = false;
                            vulnerabilityError = 'Vulnerability must specify at least one approach: vulnerability function, fragility function, damage-to-loss function, engineering demand function, or socio-economic vulnerability indicator';
                        }
                    }
                }
            }

            fieldValidationStatus.set('dataset_vulnerability', {
                isValid: vulnerabilityValid,
                errorMessage: vulnerabilityError
            });

            // 7. Validate license_url when license is "Custom"
            const license = currentFormData.license;
            const licenseUrl = currentFormData.license_url;
            let licenseUrlValid = true;
            let licenseUrlError = '';

            if (license === 'Custom') {
                if (!licenseUrl || licenseUrl.trim() === '') {
                    licenseUrlValid = false;
                    licenseUrlError = 'License URL is required when license is "Custom"';
                } else if (!licenseUrl.match(/^https?:\/\//)) {
                    licenseUrlValid = false;
                    licenseUrlError = 'License URL must start with http:// or https://';
                }
            }

            fieldValidationStatus.set('dataset_license_url', {
                isValid: licenseUrlValid,
                errorMessage: licenseUrlError
            });

        }

        function getPropertyFromSchema(fieldName) {
            if (!currentSchema) return null;
            
            const parts = fieldName.split('.');
            let current = currentSchema.properties;
            
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                
                if (current && current[part]) {
                    if (i === parts.length - 1) {
                        if (current[part].$ref) {
                            return resolveReference(current[part].$ref);
                        }
                        return current[part];
                    } else {
                        if (current[part].properties) {
                            current = current[part].properties;
                        } else if (current[part].$ref) {
                            const resolved = resolveReference(current[part].$ref);
                            if (resolved && resolved.properties) {
                                current = resolved.properties;
                            } else {
                                return current[part];
                            }
                        } else {
                            return null;
                        }
                    }
                } else {
                    return null;
                }
            }
            
            return current;
        }

        function generateDatasetId() {
            // Format: rdls_{risk_data_type}-{country}_{shortname}_{item}
            // Example: rdls_hzd-ury_ucra_fl or rdls_exp+lss-ury+ita_project_fl+pl

            const parts = ['rdls'];

            // 1. Build risk_data_type part (required)
            const riskDataTypes = currentFormData.risk_data_type || [];
            let riskTypePart = riskDataTypes.length > 0 ? riskDataTypes.join('+') : 'data';

            // 2. Get country codes (optional)
            let countryCodes = [];
            if (currentFormData.spatial?.countries) {
                countryCodes = currentFormData.spatial.countries
                    .map(c => c.toUpperCase())
                    .sort();
            }

            // Combine risk_data_type with country using hyphen
            if (countryCodes.length > 0) {
                riskTypePart += '-' + countryCodes.join('+');
            }
            parts.push(riskTypePart);

            // 3. Get shortname from project or publisher (required)
            let shortname = 'dataset';
            if (currentFormData.project?.name) {
                shortname = currentFormData.project.name
                    .toLowerCase()
                    .replace(/[^a-z0-9\s-]/g, '')
                    .replace(/[\s-]+/g, '_')
                    .substring(0, 15);
            } else if (currentFormData.attributions) {
                // Find publisher attribution
                const publisher = currentFormData.attributions.find(a => a.role === 'publisher');
                if (publisher?.name) {
                    shortname = publisher.name
                        .toLowerCase()
                        .replace(/[^a-z0-9\s-]/g, '')
                        .replace(/[\s-]+/g, '_')
                        .substring(0, 15);
                }
            }
            parts.push(shortname);

            // 4. Get item (hazard type or exposure category) (optional)
            let items = [];

            // Try to get hazard types
            if (currentFormData.hazard) {
                const hazards = Array.isArray(currentFormData.hazard) ? currentFormData.hazard : [currentFormData.hazard];
                const hazardTypes = hazards
                    .filter(h => h.type)
                    .map(h => {
                        // Convert hazard type to acronym (e.g., flood -> fl, earthquake -> eq)
                        const typeMap = {
                            'flood': 'fl',
                            'coastal_flood': 'cf',
                            'earthquake': 'eq',
                            'tsunami': 'ts',
                            'volcano': 'vo',
                            'landslide': 'ls',
                            'cyclone': 'cy',
                            'tornado': 'to',
                            'wildfire': 'wf',
                            'drought': 'dr',
                            'extreme_temperature': 'et'
                        };
                        return typeMap[h.type] || h.type.substring(0, 2);
                    });
                if (hazardTypes.length > 0) {
                    items = [...new Set(hazardTypes)]; // Remove duplicates
                }
            }

            // If no hazard types, try exposure categories
            if (items.length === 0 && currentFormData.exposure) {
                const exposures = Array.isArray(currentFormData.exposure) ? currentFormData.exposure : [currentFormData.exposure];
                const expCategories = exposures
                    .filter(e => e.category)
                    .map(e => {
                        // Convert category to short code (e.g., buildings -> bld, population -> pop)
                        const catMap = {
                            'buildings': 'bld',
                            'population': 'pop',
                            'infrastructure': 'inf',
                            'agriculture': 'agr'
                        };
                        return catMap[e.category] || e.category.substring(0, 3);
                    });
                if (expCategories.length > 0) {
                    items = [...new Set(expCategories)]; // Remove duplicates
                }
            }

            if (items.length > 0) {
                parts.push(items.join('+'));
            }

            return parts.join('_');
        }

        function packageDataset(datasetMetadata) {
            // Get the current schema version
            const version = document.getElementById('schemaVersionSelect').value;

            // Map version to schema URL format
            const versionMap = {
                '0.2': '0__2__0',
                '0.3': '0__3__0'
            };

            const schemaVersion = versionMap[version] || '0__3__0';
            const schemaUrl = `https://docs.riskdatalibrary.org/en/${schemaVersion}/rdls_schema.json`;

            // Generate unique dataset ID if not present
            if (!datasetMetadata.id) {
                datasetMetadata.id = generateDatasetId();
            }

            // Ensure links array exists and has the schema reference as first item
            if (!datasetMetadata.links) {
                datasetMetadata.links = [];
            }

            // Check if describedby link already exists
            const hasDescribedBy = datasetMetadata.links.some(link => link.rel === 'describedby');

            if (!hasDescribedBy) {
                // Add schema reference as first link with rel="describedby"
                datasetMetadata.links.unshift({
                    href: schemaUrl,
                    rel: 'describedby'
                });
            } else {
                // Update existing describedby link to current schema version
                const describedByIndex = datasetMetadata.links.findIndex(link => link.rel === 'describedby');
                datasetMetadata.links[describedByIndex].href = schemaUrl;
            }

            // Reorder fields according to schema
            const schemaFieldOrder = [
                'id', 'title', 'description', 'risk_data_type', 'version', 'purpose',
                'project', 'details', 'spatial', 'license',
                'attributions', 'sources', 'referenced_by', 'resources',
                'hazard', 'exposure', 'vulnerability', 'loss', 'links'
            ];

            const orderedMetadata = {};

            // Add fields in schema order
            schemaFieldOrder.forEach(key => {
                if (datasetMetadata[key] !== undefined) {
                    orderedMetadata[key] = datasetMetadata[key];
                }
            });

            // Add any remaining fields not in schema order
            Object.keys(datasetMetadata).forEach(key => {
                if (!schemaFieldOrder.includes(key)) {
                    orderedMetadata[key] = datasetMetadata[key];
                }
            });

            // Create the package structure (datasets only, no top-level schema field)
            const packagedData = {
                datasets: [orderedMetadata]
            };

            return packagedData;
        }

        function exportJson() {
            if (Object.keys(currentFormData).length === 0) {
                alert('No data to export. Please fill out the form first.');
                return;
            }

            const filteredData = getFilteredFormData();
            const packagedData = packageDataset(filteredData);

            // Generate filename from dataset ID
            const filename = packagedData.datasets?.[0]?.id ? `${packagedData.datasets[0].id}.json` : 'rdls_metadata.json';

            const blob = new Blob([JSON.stringify(packagedData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportXml() {
            if (Object.keys(currentFormData).length === 0) {
                alert('No data to export. Please fill out the form first.');
                return;
            }

            const filteredData = getFilteredFormData();
            const xml = jsonToXml(filteredData, 'rdls_dataset');
            const blob = new Blob([xml], {type: 'application/xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'rdls_metadata.xml';
            a.click();
            URL.revokeObjectURL(url);
        }

        function jsonToXml(obj, rootName = 'root') {
            let xml = `<?xml version="1.0" encoding="UTF-8"?>\n<${rootName}>\n`;
            
            function objectToXml(obj, indent = '  ') {
                let result = '';
                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        value.forEach(item => {
                            result += `${indent}<${key}>${escapeXml(item)}</${key}>\n`;
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        result += `${indent}<${key}>\n${objectToXml(value, indent + '  ')}${indent}</${key}>\n`;
                    } else {
                        result += `${indent}<${key}>${escapeXml(value)}</${key}>\n`;
                    }
                }
                return result;
            }
            
            xml += objectToXml(obj);
            xml += `</${rootName}>`;
            return xml;
        }

        function escapeXml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // GitHub Integration Functions
        function openGithubConfig() {
            if (Object.keys(currentFormData).length === 0) {
                alert('No data to publish. Please fill out the form first.');
                return;
            }

            // Auto-fill dataset title from metadata
            const datasetTitle = currentFormData.title || currentFormData.name || 'rdls-dataset';
            document.getElementById('datasetTitle').value = sanitizeFilename(datasetTitle);

            // Load saved GitHub token if exists
            const savedToken = sessionStorage.getItem('githubToken');
            if (savedToken) {
                document.getElementById('githubToken').value = savedToken;
            }

            const modal = new bootstrap.Modal(document.getElementById('githubConfigModal'));
            modal.show();
        }

        async function testGithubConnection() {
            const token = document.getElementById('githubToken').value;
            const repo = document.getElementById('githubRepo').value;
            const statusDiv = document.getElementById('githubConfigStatus');

            if (!token) {
                showGithubStatus('error', 'Please enter a GitHub token');
                return;
            }

            showGithubStatus('info', 'Testing connection...');

            try {
                const response = await fetch(`https://api.github.com/repos/${repo}`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (response.ok) {
                    const repoData = await response.json();
                    sessionStorage.setItem('githubToken', token);
                    showGithubStatus('success', `‚úÖ Connected to ${repoData.full_name}. You have ${repoData.permissions.push ? 'write' : 'read'} access.`);
                } else if (response.status === 401) {
                    showGithubStatus('error', '‚ùå Invalid token. Please check your Personal Access Token.');
                } else if (response.status === 404) {
                    showGithubStatus('error', '‚ùå Repository not found or no access.');
                } else {
                    showGithubStatus('error', `‚ùå Connection failed: ${response.statusText}`);
                }
            } catch (error) {
                showGithubStatus('error', `‚ùå Network error: ${error.message}`);
            }
        }

        async function publishToGithub() {
            const token = document.getElementById('githubToken').value;
            const repo = document.getElementById('githubRepo').value;
            const baseBranch = document.getElementById('githubBranch').value;
            const datasetTitle = document.getElementById('datasetTitle').value;
            const statusDiv = document.getElementById('githubConfigStatus');

            // Input validation
            if (!token) {
                showGithubStatus('error', 'Please enter a GitHub token');
                return;
            }

            if (!datasetTitle) {
                showGithubStatus('error', 'Please enter a dataset title');
                return;
            }

            // Check if form data is valid and has essential fields
            if (!currentFormData || Object.keys(currentFormData).length === 0) {
                showGithubStatus('error', 'No metadata to publish. Please fill out the form first.');
                return;
            }

            // Warn if essential fields are missing
            if (!currentFormData.title && !currentFormData.name) {
                if (!confirm('No title found in metadata. Continue publishing?')) {
                    return;
                }
            }

            // Disable publish button during operation
            const publishBtn = document.getElementById('publishToGithub');
            const testBtn = document.getElementById('testGithubConnection');
            publishBtn.disabled = true;
            testBtn.disabled = true;

            showGithubStatus('info', 'Publishing to GitHub...');

            try {
                // Package dataset first to get the ID
                const filteredData = getFilteredFormData();
                const packagedData = packageDataset(filteredData);

                // Generate filename from dataset ID, fallback to title-based naming
                const datasetId = packagedData.datasets?.[0]?.id;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
                const filename = datasetId ? `${datasetId}.json` : `${sanitizeFilename(datasetTitle)}-${timestamp}.json`;
                const branchName = datasetId ? `rdl-dataset-${datasetId}` : `rdl-dataset-${sanitizeFilename(datasetTitle)}-${timestamp}`;

                // Step 1: Get base branch SHA
                showGithubStatus('info', 'üì° Getting base branch information...');
                const baseResponse = await githubRequest(token, `repos/${repo}/git/ref/heads/${baseBranch}`);
                const baseSha = baseResponse.object.sha;

                // Step 2: Create new branch
                showGithubStatus('info', 'üåø Creating new branch...');
                await githubRequest(token, `repos/${repo}/git/refs`, {
                    method: 'POST',
                    body: JSON.stringify({
                        ref: `refs/heads/${branchName}`,
                        sha: baseSha
                    })
                });

                // Step 3: Create/update file
                showGithubStatus('info', 'üìÑ Uploading dataset file...');
                const content = btoa(JSON.stringify(packagedData, null, 2));
                const commitMessage = `Add RDLS dataset: ${datasetTitle}

Dataset published via RDLS Metadata Editor
- Title: ${filteredData.title || 'Untitled'}
- Description: ${filteredData.description ? filteredData.description.substring(0, 100) + '...' : 'No description'}
- Timestamp: ${new Date().toISOString()}`;

                await githubRequest(token, `repos/${repo}/contents/_datasets/json/${filename}`, {
                    method: 'PUT',
                    body: JSON.stringify({
                        message: commitMessage,
                        content: content,
                        branch: branchName
                    })
                });

                // Step 4: Create Pull Request
                showGithubStatus('info', 'üîÑ Creating pull request...');
                const prResponse = await githubRequest(token, `repos/${repo}/pulls`, {
                    method: 'POST',
                    body: JSON.stringify({
                        title: `Add RDLS Dataset: ${datasetTitle}`,
                        head: branchName,
                        base: baseBranch,
                        body: `## New RDLS Dataset Submission

**Dataset Title:** ${filteredData.title || 'Untitled'}

**Description:**
${filteredData.description || 'No description provided'}

**File:** \`_datasets/json/${filename}\`

**Submission Details:**
- Published via RDLS Metadata Editor
- Timestamp: ${new Date().toISOString()}
- Validation: ‚úÖ Passed

---
ü§ñ This pull request was automatically generated by the RDLS Metadata Editor.`
                    })
                });

                // Success!
                const prUrl = prResponse.html_url;
                showGithubStatus('success', `üéâ Successfully published! <a href="${prUrl}" target="_blank">View Pull Request #${prResponse.number}</a>`);

                // Store token for future use
                sessionStorage.setItem('githubToken', token);

                // Show confirmation and offer to close modal
                setTimeout(() => {
                    if (confirm(`Dataset successfully published as Pull Request #${prResponse.number}!\n\nWould you like to view it on GitHub now?`)) {
                        window.open(prUrl, '_blank');
                    }
                    // Close modal after 2 seconds regardless
                    setTimeout(() => {
                        const modal = bootstrap.Modal.getInstance(document.getElementById('githubConfigModal'));
                        if (modal) modal.hide();
                    }, 2000);
                }, 1000);

            } catch (error) {
                console.error('GitHub publish error:', error);
                let errorMessage = 'Publication failed: ';

                if (error.message.includes('422')) {
                    errorMessage += 'Branch might already exist. Try with a different dataset title.';
                } else if (error.message.includes('403')) {
                    errorMessage += 'Access denied. Please check your token permissions.';
                } else if (error.message.includes('401')) {
                    errorMessage += 'Authentication failed. Please check your token.';
                } else if (error.message.includes('404')) {
                    errorMessage += 'Repository not found or no access.';
                } else if (error.message.toLowerCase().includes('network')) {
                    errorMessage += 'Network connection error. Please check your internet connection.';
                } else {
                    errorMessage += error.message;
                }

                showGithubStatus('error', `‚ùå ${errorMessage}`);
            } finally {
                // Re-enable buttons
                publishBtn.disabled = false;
                testBtn.disabled = false;
            }
        }

        async function githubRequest(token, endpoint, options = {}) {
            const config = {
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                ...options
            };

            const response = await fetch(`https://api.github.com/${endpoint}`, config);

            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        function showGithubStatus(type, message) {
            const statusDiv = document.getElementById('githubConfigStatus');
            let className = 'alert ';
            switch(type) {
                case 'success': className += 'alert-success'; break;
                case 'error': className += 'alert-danger'; break;
                case 'info': className += 'alert-info'; break;
                default: className += 'alert-secondary';
            }
            statusDiv.className = className;
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
        }

        function sanitizeFilename(filename) {
            return filename
                .toLowerCase()
                .replace(/[^a-z0-9]/g, '-')
                .replace(/--+/g, '-')
                .replace(/^-|-$/g, '');
        }

        function autoSave() {
            localStorage.setItem('rdlsEditor_formData', JSON.stringify(currentFormData));
            localStorage.setItem('rdlsEditor_activeSections', JSON.stringify([...activeSections]));
        }

        function loadFromStorage() {
            const savedData = localStorage.getItem('rdlsEditor_formData');
            const savedSections = localStorage.getItem('rdlsEditor_activeSections');
            
            if (savedData) {
                try {
                    currentFormData = JSON.parse(savedData);
                    updatePreview();
                } catch (e) {
                    console.warn('Could not load saved form data');
                }
            }
            
            if (savedSections) {
                try {
                    const sections = JSON.parse(savedSections);
                    sections.forEach(section => {
                        if (section !== 'general') {
                            activeSections.add(section);
                            document.getElementById(`${section}Check`).checked = true;
                            addSectionTab(section);
                        }
                    });
                } catch (e) {
                    console.warn('Could not load saved sections');
                }
            }
        }

        function saveProgress() {
            autoSave();
            alert('Progress saved to browser storage!');
        }

        // Migration function to convert old field names to new format
        function migrateAttributionData(data) {
            const oldFields = ['publisher', 'creator', 'contact_point'];
            const migratedData = { ...data };

            // Migrate old attribution fields
            // Initialize attributions array if it doesn't exist
            if (!migratedData.attributions) {
                migratedData.attributions = [];
            }

            // Migrate old fields to attributions array
            oldFields.forEach(fieldName => {
                if (migratedData[fieldName] && typeof migratedData[fieldName] === 'object') {
                    // Check if this attribution doesn't already exist
                    const existingAttribution = migratedData.attributions.find(attr => attr.role === fieldName);

                    if (!existingAttribution) {
                        const newAttribution = {
                            id: `attribution_${fieldName}_migrated_${Date.now()}`,
                            role: fieldName,
                            entity: migratedData[fieldName]
                        };
                        migratedData.attributions.push(newAttribution);
                    }

                    // Remove the old field
                    delete migratedData[fieldName];
                }
            });

            // Migrate old resource field names (format -> data_format, media_type removed)
            if (migratedData.resources && Array.isArray(migratedData.resources)) {
                migratedData.resources = migratedData.resources.map(resource => {
                    const migratedResource = { ...resource };

                    // Migrate format to data_format with full names
                    if (migratedResource.format) {
                        // Map old format values to new data_format values with full names
                        const formatMapping = {
                            'geotiff': 'GeoTIFF (tif)',
                            'tif': 'GeoTIFF (tif)',
                            'cog': 'Cloud Optimized GeoTIFF (cog)',
                            'netcdf': 'NetCDF (nc)',
                            'nc': 'NetCDF (nc)',
                            'hdf5': 'HDF5 (hdf5)',
                            'zarr': 'Zarr (zarr)',
                            'geopackage': 'GeoPackage (gpkg)',
                            'gpkg': 'GeoPackage (gpkg)',
                            'geojson': 'GeoJSON (geojson)',
                            'flatgeobuf': 'FlatGeobuf (fgb)',
                            'fgb': 'FlatGeobuf (fgb)',
                            'shapefile': 'Shapefile (shp)',
                            'shp': 'Shapefile (shp)',
                            'gdb': 'File Geodatabase (gdb)',
                            'kml': 'KML (kml)',
                            'csv': 'CSV (csv)',
                            'parquet': 'Parquet (parquet)',
                            'xlsx': 'Excel (xlsx)',
                            'json': 'JSON (json)',
                            'xml': 'XML (xml)',
                            'pdf': 'PDF (pdf)',
                            'las': 'LAS (las)',
                            'copc': 'COPC (copc)'
                        };
                        migratedResource.data_format = formatMapping[migratedResource.format.toLowerCase()] || migratedResource.format;
                        delete migratedResource.format;
                    }

                    // Remove media_type (no longer used)
                    if (migratedResource.media_type !== undefined) {
                        delete migratedResource.media_type;
                    }

                    // Set default access_modality if not present
                    if (!migratedResource.access_modality) {
                        // Default to 'download' if download_url exists, otherwise 'website'
                        migratedResource.access_modality = migratedResource.download_url ? 'download' : 'website';
                    }

                    return migratedResource;
                });
            }

            return migratedData;
        }

        function loadData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            let loadedData = JSON.parse(event.target.result);

                            // Migrate attribution data from old format to new format
                            loadedData = migrateAttributionData(loadedData);

                            currentFormData = loadedData;
                            updatePreview();
                            generateForm();
                        } catch (error) {
                            alert('Invalid JSON file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function resetForm() {
            if (confirm('Are you sure you want to reset all data? This will clear all form fields and cannot be undone.')) {
                // Clear form data
                currentFormData = {};
                
                // Clear validation status
                fieldValidationStatus.clear();
                
                // Reset active sections to just general
                activeSections.clear();
                activeSections.add('general');
                
                // Uncheck all section checkboxes except general
                SECTIONS.forEach(section => {
                    const checkbox = document.getElementById(`${section}Check`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                });
                
                // Remove all section tabs except general
                SECTIONS.forEach(section => {
                    removeSectionTab(section);
                });
                
                // Hide tabs if only general is active
                document.getElementById('metadataTabs').style.display = 'none';
                
                // Clear localStorage
                localStorage.removeItem('rdlsEditor_formData');
                localStorage.removeItem('rdlsEditor_activeSections');
                
                // Clear preview
                document.getElementById('outputPreview').textContent = JSON.stringify({
                    "message": "Refactored RDLS metadata will appear here..."
                }, null, 2);
                
                // Reset validation display
                document.getElementById('validFieldCount').textContent = '0';
                document.getElementById('totalFieldCount').textContent = '0';
                document.getElementById('validationProgress').style.width = '0%';
                document.getElementById('overallValidation').className = 'badge bg-secondary';
                document.getElementById('overallValidation').textContent = 'Not validated';

                // Reset GitHub publish button
                document.getElementById('publishGitHub').disabled = true;
                document.getElementById('publishGitHub').title = 'Run validation first to enable publishing';

                
                // Regenerate form
                if (currentSchema) {
                    generateForm();
                    updateFormStatus('info', 'Form Reset Complete');
                }
                
                // Show success message
                alert('‚úÖ All data has been reset! The form is now back to its initial state.');
            }
        }

        // ================================
        // TESTING AND DEBUGGING FUNCTIONS
        // ================================

        function testUnifiedSystem() {
            console.log('=== Testing Unified Field Creation System ===');
            console.log('Schema loaded:', !!currentSchema);
            console.log('Active sections:', [...activeSections]);
            
            // Test field creation contexts
            const normalContext = new FieldCreationContext('normal');
            const modalContext = new FieldCreationContext('modal');
            const inlineContext = new FieldCreationContext('inline');
            
            console.log('Normal context ID prefix:', normalContext.idPrefix);
            console.log('Modal context ID prefix:', modalContext.idPrefix);
            console.log('Inline context ID prefix:', inlineContext.idPrefix);
            
            // Test dependency system
            console.log('\n=== Dependency System Test ===');
            Object.entries(FIELD_DEPENDENCIES).forEach(([dependent, parent]) => {
                console.log(`${dependent} depends on ${parent}`);
                
                const dependentField = document.getElementById(dependent);
                const parentField = document.getElementById(parent);
                
                console.log(`  Dependent field exists: ${!!dependentField}`);
                console.log(`  Parent field exists: ${!!parentField}`);
            });
            
            // Test specific fixes
            console.log('\n=== Testing Specific Fixes ===');
            
            // Test 1: Currency field dependency
            console.log('1. Currency field dependency test:');
            const modalCurrencyDep = FIELD_DEPENDENCIES['currency'];
            console.log(`   Modal currency depends on: ${modalCurrencyDep}`);
            const normalCurrencyDep = FIELD_DEPENDENCIES['loss.impact_and_losses.currency'];
            console.log(`   Normal currency depends on: ${normalCurrencyDep}`);
            
            // Test 2: Hazard process dependencies 
            console.log('2. Hazard process dependency test:');
            const modalProcessDep = FIELD_DEPENDENCIES['processes'];
            console.log(`   Modal processes depends on: ${modalProcessDep}`);
            const lossProcessDep = FIELD_DEPENDENCIES['loss.hazard_process'];
            console.log(`   Loss hazard_process depends on: ${lossProcessDep}`);
            
            // Test 3: Array context handling
            console.log('3. Array context test:');
            console.log(`   Inline context type: ${inlineContext.type}`);
            console.log(`   Inline context container:`, !!inlineContext.container);
            
            // Test unified factory
            console.log('\n=== Field Factory Test ===');
            const testProperty = {
                type: 'string',
                enum: ['option1', 'option2', 'option3'],
                title: 'Test Field'
            };
            
            const factory = new UnifiedFieldFactory(normalContext);
            console.log('Factory created successfully');
            
            // Test validation system
            console.log('\n=== Validation System Test ===');
            const validator = new UnifiedFieldValidator(normalContext);
            const validationResult = validator.validate('test_field', 'test_value', testProperty);
            console.log('Validation result:', validationResult);
            
            console.log('\n=== System Integration Complete ===');
            console.log('All three fixes should now be working:');
            console.log('‚úì Inline array editing in modals');
            console.log('‚úì Currency field dependency in all contexts');
            console.log('‚úì Hazard process dependency in all tabs');
        }

        // Additional helper function to test dependencies after form loads
        function testDependenciesAfterLoad() {
            setTimeout(() => {
                console.log('\n=== Post-Load Dependency Test ===');
                
                // Test hazard type -> process dependencies in all contexts
                const hazardTypeFields = [
                    'vulnerability.hazard_primary',
                    'loss.hazard_type',
                    'hazards.type'
                ];
                
                hazardTypeFields.forEach(fieldName => {
                    const field = document.getElementById(fieldName);
                    if (field) {
                        console.log(`Found hazard type field: ${fieldName}`);
                        
                        // Find its corresponding process field
                        let processFieldName;
                        if (fieldName.includes('vulnerability')) {
                            processFieldName = fieldName.replace('hazard_primary', 'hazard_process_primary');
                        } else if (fieldName.includes('loss')) {
                            processFieldName = fieldName.replace('hazard_type', 'hazard_process');
                        } else if (fieldName.includes('hazards')) {
                            processFieldName = fieldName.replace('type', 'processes');
                        }
                        
                        const processField = document.getElementById(processFieldName);
                        console.log(`  Corresponding process field ${processFieldName}: ${!!processField}`);
                        
                        if (processField) {
                            console.log(`  Process field has ${processField.options.length} options`);
                        }
                    }
                });
                
                // Test currency fields
                const currencyFields = [
                    'loss.impact_and_losses.currency',
                    'modal_currency'
                ];
                
                currencyFields.forEach(fieldName => {
                    const field = document.getElementById(fieldName);
                    if (field) {
                        const container = field.closest('.form-field, .modal-form-field');
                        console.log(`Found currency field: ${fieldName}, visible: ${container ? container.style.display !== 'none' : 'no container'}`);
                    }
                });
                
            }, 3000);
        }

        // Call test functions
        setTimeout(() => {
            if (typeof testUnifiedSystem === 'function') {
                testUnifiedSystem();
            }
            if (typeof testDependenciesAfterLoad === 'function') {
                testDependenciesAfterLoad();
            }
        }, 2000);

    </script>
</body>
</html>
